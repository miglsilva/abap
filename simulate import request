REPORT Z_SIMULATE_DEV_TRANSPORT.
********************
* Z_SIMULATE_DEV_TRANSPORT
*
* Current version : 1.02
* Version date    : 2012-02-01
* this version is not tested; Should compile on a 7.11 system
*
********************
* REVISIONS
*   *** 2012-02-01 *** this version is not tested; Should compile on a
*7.11 system;
*   2010-11-22  1.01  :  corrections - Z_DEV_WHERE_USED_LIST also
*corrected
*   2010-04-30  1.00  :  Official release
*   2009-12-13  0.01  :  Creation
*
********************
* SHORT OVERVIEW:
*   Determines if a development workbench transport will fail.
*   The program can be run before the transport request is released,
*     so that to include missing objects.
*
*   Selection screen contains the list of transport requests you want to
*     transport and the target system (RFC destination).
*
*   Result screen contains 3 parts:
*   1) ALV with transport requests of selection screen
*   2) ALV with each object of the transport
*      request(s), with a status 0, 4 or 8, and the status text
*   3) lower one contains an ALV with relationships between objects
*      and again warnings and errors
*
*   Tested on SAPKB70013 system
*
*
********************
* SELECTION SCREEN:
*   If you don't have an RFC destination. You may also use
*     HOSTNAME_SYSTEMID_INSTANCENUMBER notation (expl: mplsap101_T1V_00)
*     (you'll have to login manually with user name and password once
*for
*     each run)
*   By default, SAP standard include sources are not analyzed, but you
*may
*     request to do so if for example you want to transport SAP note
*     corrections.
*   If you will transport objects with the "overwrite originals"
*     option, then select the P_SRCSYS option so that the detection is
*not
*     performed (and so, you'll avoid incorrect error messages "source
*system
*     is different").
*
*
********************
* THE TOOL DETECTS THE FOLLOWING POSSIBLE ERRORS:
*   (legend: TR means Transport Request)
*   Checks that the subobjects required by the transported objects are
*     either transproted in the same TR, or in a previous TR indicated
*     in S_TRKORR, or already exist in the target system
*   When it detects missing objects, it looks for the transport requests
*     which contains these objects, and displays them. You can then run
*     again the tool with these new transport requests
*   If the object already exists in target system, checks that source
*system
*     in the object directory entry is the same in the 2 systems
*   Checks that the sequence of transport requests is correct
*
*
********************
* TODO:
*   1) if required object exists in target system but is inactivate,
*      program doesn't indicate an error
*   2) if transport of LIMU REPS with one source only for the first
*time,
*      SAP will create a R3TR PROG but LIMU REPT will be missing,
*program
*      doesn't indicate an error
*   3) add warning if some required objects are being modified in
*current
*      system, in TRs that are not entered in selection screen. That
*would
*      help identifying errors like a program which uses a table field
*      not yet transported
*   4) if the same TR contains both a new search help B using method
*      table A, and table A field is changed to refer to search help B,
*      SAP will try to activate table before search help. They should be
*      transported in separate TRs.
*
* False positive:
*   A) as all RFC calls are considered as normal function module calls,
*      program indicates an error if the function module doesn't exist
*in
*      the target system (though it should not test it when it is called
*      in another system, but it's too much difficult to know)
*
*
********************
* REQUIRED CUSTOM TOOLS:
*   - Where-used list (cross references) = include Z_DEV_WHERE_USED_LIST
*
*
********************
* Standard function modules used:
*   SRTT_GET_REMOTE_TADIR_ENTRY : read TADIR table
*   TR_CHECK_TYPE : get frame object (MESS -> MSAG, PROG -> PROG, FUNC
*-> FUGR, etc.)
*   TRINT_CHECK_LOCKS : get the TR which locks a given object
*   TRINT_OBJECT_NAMESPACE_INFO : identify if object is custom
*   TRINT_RESOLVE_OBJ : get subobjects of a given object
*       (R3TR PROG ZZZ -> LIMU DYNP ZZZ...1200, LIMU REPS ZZZTOP, etc.,
*       but R3TR MSAG -> nothing, and all LIMU -> LIMU unchanged, no
*error)
* >>> BEGIN OF INCLUDE Clas-LCLDEVCROSSREF-Code:
********************
* INCLUDE Z_DEV_WHERE_USED_LIST
*
* Current version : 1.01
* Version date    : 2010-11-22
*
********************
* REVISIONS
*   2010-11-22  1.01  :  correction about fictious <name>=======P
*include
*   2010-04-30  1.00  :  Official release
*   2009-12-13  0.01  :  Creation
*
********************
TYPE-POOLS: RS.
* >>> BEGIN OF INCLUDE LCL_TRAN:
*----------------------------------------------------------------------*
*       CLASS lcl_tran DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_tran DEFINITION.
  PUBLIC SECTION.

    TYPES : BEGIN OF type_s_cobj,
              field TYPE tstca-field,
              value TYPE tstca-value,
              olen  TYPE dfies-outputlen,
            END OF type_s_cobj.
    TYPES type_t_cobj TYPE TABLE OF type_s_cobj.

* report transaction
    TYPES : BEGIN OF type_s_report,
              program_name      TYPE tstc-pgmna,
              screen_number     TYPE tstc-dypno,
              program_variant   TYPE rsstcd-repo_vari,
              auth_object       TYPE tstca-objct,
              t_cobj            TYPE TABLE OF type_s_cobj WITH DEFAULT
KEY,
            END OF type_s_report.
* dialog transaction
    TYPES : BEGIN OF type_s_dialog,
              program_name      TYPE tstc-pgmna,
              screen_number     TYPE tstc-dypno,
              allow_std_transac_variant TYPE flag,
              auth_object       TYPE tstca-objct,
              t_cobj            TYPE TABLE OF type_s_cobj WITH DEFAULT
KEY,
            END OF type_s_dialog.
* parameter transaction
    TYPES : BEGIN OF type_s_parameter,
              called_tcode      TYPE tstc-tcode,
              skip_init_screen  TYPE flag,
              inherit_gui_attr  TYPE flag,
              program_name      TYPE tstc-pgmna,
              screen_number     TYPE tstc-dypno,
              t_param           TYPE s_param,
            END OF type_s_parameter.
* variant transaction
    TYPES : BEGIN OF type_s_variant,
              called_tcode      TYPE tstc-tcode,
              transac_variant   TYPE rsstcd-variant,
              cross_client      TYPE flag,
              inherit_gui_attr  TYPE flag,
            END OF type_s_variant.
* object transaction
    TYPES : BEGIN OF type_s_object,
              transaction_model TYPE flag,
              local_class       TYPE flag,
              global_class_name TYPE seoclsname,
              local_class_name  TYPE seoclsname,
              method_name       TYPE seocpdname,
              program_name      TYPE tstc-pgmna,
              update_mode       TYPE char01, "only for transaction model
              auth_object       TYPE tstca-objct,
              t_cobj            TYPE TABLE OF type_s_cobj WITH DEFAULT
KEY,
            END OF type_s_object.

    DATA :    tcode        TYPE tstc-tcode,
              type         TYPE char01,
              s_report     TYPE type_s_report,
              s_dialog     TYPE type_s_dialog,
              s_object     TYPE type_s_object,
              s_parameter  TYPE type_s_parameter,
              s_variant    TYPE type_s_variant,
              locked_via_sm01 TYPE flag,
              professional TYPE flag,
              easy_web     TYPE flag,
              ew_service   TYPE tstcc-s_service, "easy web
              ew_pervasive TYPE tstcc-s_pervas, "easy web
              gui_html     TYPE tstcc-s_webgui,
              gui_win32    TYPE tstcc-s_win32,
              gui_java     TYPE tstcc-s_platin.

    METHODS constructor IMPORTING i_tcode TYPE tcode.

ENDCLASS.                    "lcl_tran DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_tran IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_tran IMPLEMENTATION.

  METHOD constructor.

    FIELD-SYMBOLS <ls_tstc> TYPE tstc.
    FIELD-SYMBOLS <ls_tstcc> TYPE tstcc.
    FIELD-SYMBOLS <lt_cobj> TYPE type_t_cobj.
    FIELD-SYMBOLS <ls_rsstcd> TYPE rsstcd.
    FIELD-SYMBOLS <lt_param> TYPE s_param.
    FIELD-SYMBOLS <l_easy_web> TYPE flag.
    FIELD-SYMBOLS <l_professional> TYPE flag.
    FIELD-SYMBOLS <l_transaction_variant_flag> TYPE flag.
    FIELD-SYMBOLS <l_transaction_type> TYPE tstc-cinfo.
    FIELD-SYMBOLS <l_authorization_object_flag> TYPE syhex01.
    FIELD-SYMBOLS <l_locked_via_sm01> TYPE syhex01.
    FIELD-SYMBOLS <l_gui_inherit> TYPE flag.
    DATA l_auth_object TYPE tstca-objct.

    PERFORM select_tstc_tables_new IN PROGRAM saplseuk
          USING i_tcode sy-langu sy-langu.

    ASSIGN ('(SAPLSEUK)TSTC') TO <ls_tstc>.
    ASSIGN ('(SAPLSEUK)TSTCC') TO <ls_tstcc>.
    ASSIGN ('(SAPLSEUK)COBJ[]') TO <lt_cobj>.
    ASSIGN ('(SAPLSEUK)RSSTCD') TO <ls_rsstcd>.
    ASSIGN ('(SAPLSEUK)PARAM[]') TO <lt_param>.
    ASSIGN ('(SAPLSEUK)G_IAC_EWT') TO <l_easy_web>.
    ASSIGN ('(SAPLSEUK)G_PROFI_TRAN') TO <l_professional>.

    ASSIGN ('(SAPLSEUK)PARAM_VARI') TO <l_transaction_variant_flag>.
    ASSIGN ('(SAPLSEUK)TC_TYP') TO <l_transaction_type>.
    ASSIGN ('(SAPLSEUK)TC_CHK') TO <l_authorization_object_flag>.
    ASSIGN ('(SAPLSEUK)TC_ENQ') TO <l_locked_via_sm01>.
    ASSIGN ('(SAPLSEUK)G_GUI_INHE') TO <l_gui_inherit>.

    tcode = i_tcode.

    IF NOT <l_authorization_object_flag> IS INITIAL.
      SELECT SINGLE objct FROM tstca
            INTO l_auth_object
            WHERE tcode = i_tcode.
    ENDIF.

    CASE <l_transaction_type>.
      WHEN '80'.
        type = 'R'.
        s_report-program_name = <ls_tstc>-pgmna.
        s_report-screen_number = <ls_tstc>-dypno.
        s_report-program_variant = <ls_rsstcd>-repo_vari.
        s_report-auth_object = l_auth_object.
        s_report-t_cobj = <lt_cobj>.
      WHEN '00'.
        type = 'D'.
        s_dialog-program_name  = <ls_tstc>-pgmna.
        s_dialog-screen_number = <ls_tstc>-dypno.
        s_dialog-allow_std_transac_variant = <ls_rsstcd>-trans_var.
        s_dialog-auth_object   = l_auth_object.
        s_dialog-t_cobj        = <lt_cobj>.
      WHEN '01'.
        type = 'M'. "menu area (obsolete transaction type)
      WHEN '08'.
        type = 'O'.
        IF <ls_rsstcd>-call_tcode = 'OS_APPLICATION'.
          s_object-transaction_model = 'X'.
          s_object-global_class_name = <ls_rsstcd>-classname.
* Update mode is stored in TSTCP-PARM like %UPDATE_MODE=?%
          IF <ls_rsstcd>-s_upddir = 'X'.
            s_object-update_mode = 'S'.
          ELSEIF <ls_rsstcd>-s_updtask = 'X'.
            s_object-update_mode = 'A'.
          ELSEIF <ls_rsstcd>-s_updlok = 'X'.
            s_object-update_mode = 'L'.
          ENDIF.
        ELSE.
          IF NOT <ls_tstc>-pgmna IS INITIAL.
            s_object-local_class       = 'X'.
            s_object-program_name      = <ls_tstc>-pgmna.
            s_object-local_class_name  = <ls_rsstcd>-classname.
          ELSE.
            s_object-global_class_name = <ls_rsstcd>-classname.
          ENDIF.
        ENDIF.
        s_object-method_name   = <ls_rsstcd>-method.
        s_object-auth_object   = l_auth_object.
        s_object-t_cobj        = <lt_cobj>.
      WHEN '02'.
        IF <l_transaction_variant_flag> = 'X'.
          type = 'V'. "variant transaction
          s_variant-called_tcode      = <ls_rsstcd>-call_tcode.
          s_variant-transac_variant   = <ls_rsstcd>-variant.
          s_variant-cross_client      = <ls_rsstcd>-s_ind_vari.
          s_variant-inherit_gui_attr  = <l_gui_inherit>.
        ELSE.
          type = 'P'. "parameter transaction
          s_parameter-called_tcode      = <ls_rsstcd>-call_tcode.
          s_parameter-skip_init_screen  = <ls_rsstcd>-st_skip_1.
          s_parameter-inherit_gui_attr  = <l_gui_inherit>.
          s_parameter-program_name      = <ls_tstc>-pgmna.
          s_parameter-screen_number     = <ls_tstc>-dypno.
          s_parameter-t_param           = <lt_param>.
        ENDIF.
    ENDCASE.

    IF NOT <l_locked_via_sm01> IS INITIAL.
      locked_via_sm01 = 'X'.
    ENDIF.

    professional = <l_professional>.
    easy_web = <l_easy_web>.
    ew_service   = <ls_tstcc>-s_service.
    ew_pervasive = <ls_tstcc>-s_pervas.
    gui_html     = <ls_tstcc>-s_webgui.
    gui_win32    = <ls_tstcc>-s_win32.
    gui_java     = <ls_tstcc>-s_platin.

  ENDMETHOD.                    "constructor
ENDCLASS.                    "lcl_tran IMPLEMENTATION
* <<< END OF INCLUDE

INCLUDE ttypleng.
*----------------------------------------------------------------------*
*       CLASS LCL_convert_wbobj_key_2_e071 DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_convert_wbobj_key_2_e071 DEFINITION.
  PUBLIC SECTION.
    TYPES : BEGIN OF type_s_docu_key,
              docu_id      TYPE dokhl-id,
              docu_object  TYPE dokhl-object,
            END OF type_s_docu_key.
    TYPES : BEGIN OF type_s_tobj_key,
              objectname   TYPE objh-objectname,
              objecttype   TYPE objh-objecttype,
            END OF type_s_tobj_key.
    TYPES : BEGIN OF type_s_sott_key,
              paket        TYPE sotr_pack,
              concept      TYPE sotr_conc,
            END OF type_s_sott_key.
    TYPES type_spad(5) TYPE c.
    TYPES : BEGIN OF type_s_spcs_key,
              spad_type TYPE type_spad,
              codepage  TYPE tcp00-cpcodepage,
            END OF type_s_spcs_key.
    TYPES : BEGIN OF type_s_spsv_key,
              spad_type  TYPE type_spad,
              server     TYPE tspsv-server,
            END OF type_s_spsv_key.
    TYPES : BEGIN OF type_s_spdv_key,
              spad_type  TYPE type_spad,
              device     TYPE tsp03-padest,
            END OF type_s_spdv_key.
    TYPES : BEGIN OF type_s_splo_key,
              spad_type     TYPE type_spad,
              paper_format  TYPE tsp1d-papart,
            END OF type_s_splo_key.
    TYPES : BEGIN OF type_s_prin_key,
              spad_type     TYPE type_spad,
              printer_type  TYPE tsp0a-patype,
            END OF type_s_prin_key.
    TYPES : BEGIN OF type_s_slom_key,
              spad_type              TYPE type_spad,
              logical_output_system  TYPE tsploms-name,
            END OF type_s_slom_key.
    TYPES : BEGIN OF type_s_soms_key,
              spad_type          TYPE type_spad,
              read_output_system TYPE tsproms-name,
            END OF type_s_soms_key.
    TYPES : BEGIN OF type_s_scp_key,
              bcset_id TYPE scpr_id,
              category TYPE scpr_ctgry,
            END OF type_s_scp_key.
    TYPES : BEGIN OF type_s_dynp_key,
              program_name   TYPE d020s-prog,
              screen_number  TYPE d020s-dnum,
            END OF type_s_dynp_key.
    TYPES : BEGIN OF type_s_vari_key,
              variant_name TYPE vari-variant,
              program_name TYPE vari-report,
            END OF type_s_vari_key.
    TYPES : BEGIN OF type_s_mess_key,
              msg_class_name  TYPE t100-arbgb,
              msg_number      TYPE t100-msgnr,
            END OF type_s_mess_key.
    TYPES : BEGIN OF type_s_meth_key,
              class_name   TYPE seoclsname,
              method_name  TYPE seocpdname,
            END OF type_s_meth_key.
    TYPES : BEGIN OF type_s_wdyc_key,
              webdynpro_name    TYPE wdy_component_name,
              controller_name   TYPE wdy_controller_name,
            END OF type_s_wdyc_key.
    TYPES : BEGIN OF type_s_wdyv_key,
              webdynpro_name    TYPE wdy_component_name,
              view_name         TYPE wdy_view_name,
            END OF type_s_wdyv_key.
    TYPES : BEGIN OF type_s_wapp_key,
              appl_name     TYPE o2applname,
              page_name     TYPE o2page,
            END OF type_s_wapp_key.
    TYPES : BEGIN OF type_s_wbobj_key,
*          obj_name   TYPE e071-obj_name,
          object     TYPE e071-object, "DYNP, PROG, FUGR, FUNC, etc.
          s_docu     TYPE type_s_docu_key,
          include    TYPE progname,
          trkorr     TYPE trkorr,
          s_tobj     TYPE type_s_tobj_key,
          s_sott     TYPE type_s_sott_key,
          s_spcs     TYPE type_s_spcs_key,
          s_spsv     TYPE type_s_spsv_key,
          s_spdv     TYPE type_s_spdv_key,
          s_splo     TYPE type_s_splo_key,
          s_prin     TYPE type_s_prin_key,
          s_slom     TYPE type_s_slom_key,
          s_soms     TYPE type_s_soms_key,
          s_scp      TYPE type_s_scp_key,
          file       TYPE cts_guid32,
          s_dynp     TYPE type_s_dynp_key,
          s_vari     TYPE type_s_vari_key,
          s_mess     TYPE type_s_mess_key,
          s_meth     TYPE type_s_meth_key,
          s_wdyc     TYPE type_s_wdyc_key,
          s_wdyv     TYPE type_s_wdyv_key,
          s_wapp     TYPE type_s_wapp_key,
        END OF type_s_wbobj_key.
    CLASS-METHODS execute
          IMPORTING
            is_wbobj_key    TYPE  type_s_wbobj_key
          CHANGING
            es_e071_key     TYPE  CTS_OBJECT_KEY.
ENDCLASS.                    "LCL_convert_wbobj_key_2_e071 DEFINITION



*----------------------------------------------------------------------*
*       CLASS LCL_convert_wbobj_key_2_e071 DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_convert_wbobj_key_2_e071 IMPLEMENTATION.
  METHOD execute.
    DATA ls_ko100 TYPE ko100.

* determine if type (PROG, CLAS, DYNP, etc.) corresponds to R3TR or LIMU
    CALL FUNCTION 'TR_GET_PGMID_FOR_OBJECT'
      EXPORTING
        iv_object      = is_wbobj_key-object
      IMPORTING
        es_type        = ls_ko100
      EXCEPTIONS
        illegal_object = 1
        OTHERS         = 2.

    CLEAR es_e071_key.
    es_e071_key-pgmid  = ls_ko100-pgmid. "usually R3TR or LIMU
    es_e071_key-object = is_wbobj_key-object.

    CASE is_wbobj_key-object.

      WHEN 'DOCU'.
        es_e071_key-obj_name(2) = is_wbobj_key-s_docu-docu_id.
        es_e071_key-obj_name+2 = is_wbobj_key-s_docu-docu_object.


      WHEN 'SOTT' OR 'SOTU'.
        es_e071_key-obj_name(30) = is_wbobj_key-s_sott-paket.
        es_e071_key-obj_name+30 = is_wbobj_key-s_sott-concept.


      WHEN 'TOBJ'.
        CONCATENATE is_wbobj_key-s_tobj-objectname
                    is_wbobj_key-s_tobj-objecttype
            INTO es_e071_key-obj_name.


      WHEN 'MERG' OR 'RELE' OR 'COMM'.
        es_e071_key-obj_name = is_wbobj_key-trkorr.


      WHEN 'SPCS'.
        es_e071_key-obj_name = is_wbobj_key-s_spcs-codepage.
      WHEN 'SPSV'.
        es_e071_key-obj_name = is_wbobj_key-s_spsv-server.
      WHEN 'SPDV'.
        SELECT SINGLE name FROM tsp03d INTO es_e071_key-obj_name
              WHERE padest = is_wbobj_key-s_spdv-device.
      WHEN 'SPLO'.
        es_e071_key-obj_name = is_wbobj_key-s_splo-paper_format.
      WHEN 'PRIN'.
        es_e071_key-obj_name = is_wbobj_key-s_prin-printer_type.
      WHEN 'SLOM'.
        es_e071_key-obj_name =
is_wbobj_key-s_slom-logical_output_system.
      WHEN 'SOMS'.
        es_e071_key-obj_name = is_wbobj_key-s_soms-read_output_system.


      WHEN 'SCP1'.
        es_e071_key-obj_name = is_wbobj_key-s_scp-bcset_id.
      WHEN 'SCP2'.
        es_e071_key-obj_name = is_wbobj_key-s_scp-bcset_id.


      WHEN 'FILE'.
        es_e071_key-obj_name = is_wbobj_key-file.

      WHEN 'REPO'.
        es_e071_key-obj_name = is_wbobj_key-include.

      WHEN 'DYNP'.
        es_e071_key-pgmid    = 'LIMU'.
        es_e071_key-obj_name+gc_prog(gc_dynp) =
is_wbobj_key-s_dynp-screen_number.
        es_e071_key-obj_name(gc_prog)         =
is_wbobj_key-s_dynp-program_name.

      WHEN 'VARI' OR 'VARX'.
        es_e071_key-obj_name+gc_prog(gc_vari) =
is_wbobj_key-s_vari-variant_name.
        es_e071_key-obj_name(gc_prog)         =
is_wbobj_key-s_vari-program_name.

      WHEN 'MESS'.
        es_e071_key-pgmid    = 'LIMU'.
        CONCATENATE is_wbobj_key-s_mess-msg_class_name
                    is_wbobj_key-s_mess-msg_number
              INTO es_e071_key-obj_name.

      WHEN 'METH'.
        es_e071_key-pgmid    = 'LIMU'.
        es_e071_key-obj_name+gc_clas(gc_meth) =
is_wbobj_key-s_meth-method_name.
        es_e071_key-obj_name(gc_clas)         =
is_wbobj_key-s_meth-class_name.

* Web Dynpro controller
      WHEN 'WDYC'.
        es_e071_key-obj_name+gc_wdyn(gc_wdyc) =
is_wbobj_key-s_wdyc-controller_name.
        es_e071_key-obj_name(gc_wdyn) =
is_wbobj_key-s_wdyc-webdynpro_name.

* Web Dynpro view
      WHEN 'WDYV'.
        es_e071_key-obj_name+gc_wdyn(gc_wdyv) =
is_wbobj_key-s_wdyv-view_name.
        es_e071_key-obj_name(gc_wdyn) =
is_wbobj_key-s_wdyv-webdynpro_name.

* Page/Controller of a BSP Application
      WHEN 'WAPD' OR 'WAPP'.
        es_e071_key-obj_name+gc_wapa(gc_wapp) =
is_wbobj_key-s_wapp-page_name.
        es_e071_key-obj_name(gc_wapa) = is_wbobj_key-s_wapp-appl_name.

      WHEN OTHERS.
* FUGR, CLAS, FUNC, PROG, etc.
        es_e071_key-obj_name = is_wbobj_key-object.

    ENDCASE.
  ENDMETHOD.                    "execute
ENDCLASS.                    "LCL_convert_wbobj_key_2_e071 DEFINITION


*----------------------------------------------------------------------*
CLASS lcl_sap_fm_ddif_typeinfo_get DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS execute
      IMPORTING
        i_tabname TYPE tabname
      CHANGING
        e_object TYPE ddtypekind.
ENDCLASS.                    "lcl_sap_fm_DDIF_TYPEINFO_GET DEFINITION

*----------------------------------------------------------------------*
CLASS lcl_sap_fm_ddif_typeinfo_get IMPLEMENTATION.
  METHOD execute.
    DATA l_typename TYPE typename.
    DATA l_typekind TYPE ddtypekind.

    CLEAR e_object.

    l_typename = i_tabname.
    CALL FUNCTION 'DDIF_TYPEINFO_GET'
      EXPORTING
        typename = l_typename
      IMPORTING
        typekind = l_typekind.
    e_object = l_typekind.
  ENDMETHOD.                    "execute
ENDCLASS.                    "lcl_sap_fm_DDIF_TYPEINFO_GET
*IMPLEMENTATION.


*----------------------------------------------------------------------*
CLASS lcl_sap_fm_tr_check_type DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS execute
        IMPORTING
          wi_e071  TYPE e071
        EXPORTING
          we_lock_key TYPE tlock_int
          we_tadir TYPE tadir.
ENDCLASS.                    "lcl_sap_fm DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_sap_fm_tr_check_type IMPLEMENTATION.
  METHOD execute.
    DATA ls_e071 TYPE e071.
* TR_CHECK_TYPE returns empty when object = VARX !
* With VARI, it returns program name
    ls_e071 = wi_e071.
    IF ls_e071-object = 'VARX'.
      ls_e071-object = 'VARI'.
    ENDIF.
    CALL FUNCTION 'TR_CHECK_TYPE'
      EXPORTING
        wi_e071     = ls_e071
      IMPORTING
        we_tadir    = we_tadir
        we_lock_key = we_lock_key.
  ENDMETHOD.                    "TR_CHECK_TYPE
ENDCLASS.                    "lcl_sap_fm IMPLEMENTATION


*----------------------------------------------------------------------*
*       CLASS lcx_dev_cross_ref_fm_call DEFINITION
*----------------------------------------------------------------------*
CLASS lcx_dev_cross_ref_fm_call DEFINITION INHERITING FROM
cx_static_check.
  PUBLIC SECTION.
    METHODS constructor.
    CONSTANTS fffff TYPE sotr_conc VALUE
'86BE4E4B5D93F764E1000000AC12017F'.
    CLASS-DATA fbname2 TYPE rs38l_fnam.
    CLASS-DATA excname2 TYPE rs38l_exce.
    DATA fbname TYPE rs38l_fnam.
    DATA excname TYPE rs38l_exce.
ENDCLASS.                    "lcx_dev_cross_ref_fm_call DEFINITION
*----------------------------------------------------------------------*
*       CLASS lcx_dev_cross_ref_fm_call IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcx_dev_cross_ref_fm_call IMPLEMENTATION.
  METHOD constructor.
    CALL METHOD super->constructor.
    fbname = fbname2.
    excname = excname2.
  ENDMETHOD.                    "constructor
ENDCLASS.                    "lcx_dev_cross_ref_fm_call IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_dev_cross_ref DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_dev_cross_ref DEFINITION.
  PUBLIC SECTION.
    TYPES : BEGIN OF type_s_e071_objkey,
              pgmid     TYPE e071-pgmid,
              object    TYPE e071-object,
              obj_name  TYPE e071-obj_name,
            END OF type_s_e071_objkey.
    TYPES type_t_e071_key TYPE STANDARD TABLE OF type_s_e071_objkey.
    TYPES soft_or_hard TYPE c LENGTH 1.
    TYPES : BEGIN OF type_s_e071_rel,
              soft_or_hard TYPE soft_or_hard,
              subobject TYPE type_s_e071_objkey,
            END OF type_s_e071_rel.
    TYPES type_t_e071_rel TYPE STANDARD TABLE OF type_s_e071_rel.

    CLASS-METHODS get_reqobj
          IMPORTING
            is_e071_key   TYPE type_s_e071_objkey
          EXPORTING
            et_e071_key   TYPE type_t_e071_rel
          RAISING
            cx_enh_root.
    CLASS-METHODS get_subobj
          IMPORTING
            is_object     TYPE type_s_e071_objkey
          EXPORTING
            et_subobject  TYPE type_t_e071_key
          RAISING
            lcx_dev_cross_ref_fm_call.

  PRIVATE SECTION.
    CLASS-DATA gt_e071_key TYPE type_t_e071_key.

    CLASS-METHODS get_include_required_objects
          IMPORTING
            i_include     TYPE progname.
    CLASS-METHODS get_devc_required_objects
          IMPORTING
            i_package_name TYPE devclass.
    CLASS-METHODS tablstruc_field
        IMPORTING
          is_dd03p    TYPE dd03p
          is_e071_key TYPE type_s_e071_objkey.
    CLASS-METHODS collect
          IMPORTING
            soft_or_hard  TYPE soft_or_hard
            y             TYPE type_s_e071_objkey.  "subobject
ENDCLASS.                    "lcl_dev_cross_ref DEFINITION


*----------------------------------------------------------------------*
*       CLASS lcl_dev_cross_ref IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcl_dev_cross_ref IMPLEMENTATION.
  DEFINE mac_collect.
    assert &1 = &1. assert &3 = &3. call method collect
      exporting
        soft_or_hard = &2
        y            = &4.
  END-OF-DEFINITION.
  METHOD get_subobj.
    DATA lt_t100     TYPE TABLE OF t100.
    DATA ls_t100     TYPE t100.
    DATA lt_varid    TYPE TABLE OF varid.
    DATA ls_varid    TYPE varid.
    DATA ls_e071_key TYPE type_s_e071_objkey.
    DATA ls_e071     TYPE e071.
    DATA lt_vrso_source TYPE TABLE OF vrso.
    DATA ls_vrso        TYPE vrso.

    REFRESH et_subobject.

    IF is_object-pgmid = 'R3TR'.
      CASE is_object-object.
        WHEN 'MSAG'.
          SELECT * FROM t100 INTO TABLE lt_t100 WHERE arbgb =
is_object-obj_name.
          LOOP AT lt_t100 INTO ls_t100.
            ls_e071_key-pgmid    = 'LIMU'.
            ls_e071_key-object   = 'MESS'.
            CONCATENATE is_object-obj_name ls_t100-msgnr INTO
ls_e071_key-obj_name.
            APPEND ls_e071_key TO et_subobject.
          ENDLOOP.
        WHEN OTHERS.

* Call TRINT_RESOLVE_OBJ on each system to check presence of all
*subobjects
*   Caution: this subobjets n'existent pas forcï¿½ment.
* If subobject belongs to a frame object, check that this last one
*exists in the
*   same transport request or one transported before.
*   For example, if it contains FUGR object, all its LIMU FUNC are
*   also transported.
          ls_e071-object = is_object-object.
          ls_e071-obj_name = is_object-obj_name.
          REFRESH lt_vrso_source.
          CALL FUNCTION 'TRINT_RESOLVE_OBJ'
            EXPORTING
              is_e071             = ls_e071
            TABLES
              et_vrso             = lt_vrso_source
            EXCEPTIONS
              not_versionable     = 1
              communication_error = 2
              OTHERS              = 3.
          IF sy-subrc <> 0.
            DEFINE exception1.
              lcx_dev_cross_ref_fm_call=>excname2 = &1.
              raise exception type lcx_dev_cross_ref_fm_call.
            END-OF-DEFINITION.
            lcx_dev_cross_ref_fm_call=>fbname2 = 'TRINT_RESOLVE_OBJ'.
            CASE sy-subrc.
              WHEN 1. exception1 'NOT_VERSIONABLE'.
              WHEN 2. exception1 'COMMUNICATION_ERROR'.
              WHEN 3. exception1 'OTHERS'.
            ENDCASE.

          ENDIF.
          LOOP AT lt_vrso_source INTO ls_vrso.
            ls_e071_key-pgmid    = 'LIMU'.
            ls_e071_key-object   = ls_vrso-objtype.
            ls_e071_key-obj_name = ls_vrso-objname.
            APPEND ls_e071_key TO et_subobject.
          ENDLOOP.
      ENDCASE.
    ENDIF.

    CASE is_object-object.
      WHEN 'PROG' OR 'REPS' OR 'REPO'.
* propose automatically system variants
        SELECT * FROM varid CLIENT SPECIFIED
              INTO TABLE lt_varid
              WHERE mandt     = '000'  "system variants are only in
*client 000
                AND report    = is_object-obj_name
                AND transport = space. "system variant
        LOOP AT lt_varid INTO ls_varid.
          ls_e071_key-pgmid    = 'LIMU'.
          ls_e071_key-object   = 'VARX'.
          CONCATENATE ls_varid-report ls_varid-variant INTO
ls_e071_key-obj_name RESPECTING BLANKS.
          APPEND ls_e071_key TO et_subobject.
        ENDLOOP.
    ENDCASE.

  ENDMETHOD.                    "get_subobj

  METHOD collect.
    DATA ls_e071_key TYPE type_s_e071_rel.

    ls_e071_key-soft_or_hard = soft_or_hard.
    ls_e071_key-subobject    = y.
    APPEND ls_e071_key TO gt_e071_key.

  ENDMETHOD.                    "collect

  METHOD get_devc_required_objects.
    DATA lo_package TYPE REF TO if_package.
    DATA ls_e071_key TYPE type_s_e071_objkey.
    DATA is_e071_key TYPE type_s_e071_objkey.

    CALL METHOD cl_package=>load_package
      EXPORTING
        i_package_name             = i_package_name
      IMPORTING
        e_package                  = lo_package
      EXCEPTIONS
        object_not_existing        = 1
        unexpected_error           = 2
        intern_err                 = 3
        object_locked_and_modified = 4
        OTHERS                     = 5.
    IF sy-subrc <> 0.
    ENDIF.
    IF lo_package IS BOUND.
* SUB-PACKAGES
      DATA lto_package_sub TYPE scompaklis.
      CALL METHOD lo_package->get_sub_packages
        IMPORTING
          e_sub_packages   = lto_package_sub
        EXCEPTIONS
          object_invalid   = 1
          leaf_package     = 2
          unexpected_error = 3
          OTHERS           = 4.
      IF sy-subrc <> 0.
      ENDIF.
      DATA lo_package_sub TYPE REF TO if_package.
      LOOP AT lto_package_sub INTO lo_package_sub.
        ls_e071_key-pgmid    = 'R3TR'.
        ls_e071_key-object   = 'DEVC'.
        ls_e071_key-obj_name = lo_package_sub->package_name.
        mac_collect is_e071_key 'S' '' ls_e071_key.
      ENDLOOP.
* SUPER PACKAGE
      DATA lo_package_super TYPE REF TO if_package.
      CALL METHOD lo_package->get_super_package
        IMPORTING
          e_super_package = lo_package_super
        EXCEPTIONS
          root_package    = 1
          OTHERS          = 2.
      IF sy-subrc = 0.

        ls_e071_key-pgmid    = 'R3TR'.
        ls_e071_key-object   = 'DEVC'.
        ls_e071_key-obj_name = lo_package_super->package_name.
        mac_collect is_e071_key 'H' '' ls_e071_key.

        DATA lo_interface TYPE REF TO if_package_interface.
        DATA lto_interface TYPE tpak_package_interface_list.
        CALL METHOD lo_package->get_interfaces
          IMPORTING
            e_package_interfaces = lto_interface.
        LOOP AT lto_interface INTO lo_interface.
          ls_e071_key-pgmid    = 'R3TR'.
          ls_e071_key-object   = 'PINF'.
          ls_e071_key-obj_name = lo_interface->interface_name.
          mac_collect is_e071_key 'S' '' ls_e071_key.
        ENDLOOP.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "get_devc_required_objects

  METHOD get_include_required_objects.
    DATA ls_e071_key TYPE type_s_e071_objkey.
    DATA lt_incl TYPE TABLE OF rseuinc.
    FIELD-SYMBOLS <ls_incl> TYPE rseuinc.
    DATA lt_cross TYPE TABLE OF cross.
    FIELD-SYMBOLS <ls_cross> TYPE cross.
    DATA l_progname TYPE syrepid.
    DATA l_subc TYPE trdir-subc.
    DATA lte_main TYPE TABLE OF d010inc-master.
    FIELD-SYMBOLS <l_main> TYPE d010inc-master.
    DATA l_object TYPE e071-object.
    DATA ls_wbobj_key TYPE
lcl_convert_wbobj_key_2_e071=>type_s_wbobj_key.
    DATA l_class_is_name TYPE  c.
    DATA l_class_name TYPE  seoclsname.
    DATA l_class_is_method_name TYPE  c.
    DATA l_class_method_name TYPE  seocpdname.
    DATA is_e071_key TYPE type_s_e071_objkey.

    l_progname = i_include.


* Get list of INCLUDE statements.
    CALL FUNCTION 'RS_GET_ALL_INCLUDES'
      EXPORTING
        program      = l_progname
      TABLES
        includetab   = lt_incl
      EXCEPTIONS
        not_existent = 0
        no_program   = 0
        OTHERS       = 3.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
* 2010-11-22
* D010INC table may sometimes contain an erroneous entry:
* for classname===...===CP, RS_GET_ALL_INCLUDES returns
* packagename===...===P that doesn't exist
    DELETE lt_incl WHERE master+30 = 'P'.

* For each include, get all objects it is using.
    LOOP AT lt_incl ASSIGNING <ls_incl>.

* Determine the type of the include
      CALL FUNCTION 'RS_PROGNAME_SPLIT'
        EXPORTING
          progname_with_namespace = <ls_incl>-master
        IMPORTING
          class_is_name           = l_class_is_name
          class_name              = l_class_name
          class_is_method_name    = l_class_is_method_name
          class_method_name       = l_class_method_name
        EXCEPTIONS
          delimiter_error         = 1
          OTHERS                  = 2.
      IF sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      ENDIF.
      IF 0 = 1.
      ELSEIF l_class_is_name = 'X'.
* The include refers to a class section or class frame program
        ls_e071_key-pgmid    = 'R3TR'.
        ls_e071_key-object   = 'CLAS'.
        ls_e071_key-obj_name = l_class_name.
        mac_collect is_e071_key 'H' '' ls_e071_key .
      ELSEIF l_class_is_method_name = 'X'.
* The include refers to a class method
        ls_wbobj_key-object = 'METH'.
        ls_wbobj_key-s_meth-class_name = l_class_name.
        ls_wbobj_key-s_meth-method_name = l_class_method_name.
        CALL METHOD lcl_convert_wbobj_key_2_e071=>execute
          EXPORTING
            is_wbobj_key = ls_wbobj_key
          CHANGING
            es_e071_key  = ls_e071_key.
        mac_collect is_e071_key 'H' '' ls_e071_key .
      ELSE.
        ls_e071_key-pgmid    = 'R3TR'.
        ls_e071_key-object   = 'PROG'.
        ls_e071_key-obj_name = <ls_incl>-master.
        mac_collect is_e071_key 'H' '' ls_e071_key .
      ENDIF.
    ENDLOOP.


* Get all DDIC types referenced in the include
    DATA lt_wbcrossgt TYPE TABLE OF wbcrossgt.
    DATA ls_wbcrossgt TYPE wbcrossgt.
    DATA l_ddictype TYPE wbcrossgt-name.
    DATA l_remain TYPE wbcrossgt-name.
    SELECT * FROM wbcrossgt INTO TABLE lt_wbcrossgt
          WHERE include = i_include
            AND otype = 'TY'.
    LOOP AT lt_wbcrossgt INTO ls_wbcrossgt.
      SPLIT ls_wbcrossgt-name AT '\' INTO l_ddictype l_remain.
* Get ddic object type
      IF l_remain IS INITIAL.
        DATA l_tabname TYPE tabname.
        l_tabname = l_ddictype.
        CALL METHOD lcl_sap_fm_ddif_typeinfo_get=>execute
          EXPORTING
            i_tabname = l_tabname
          CHANGING
            e_object  = l_object.
        IF l_object IS INITIAL.
* If it's not a DDIC type, then it's a class or interface
          DATA l_clstype TYPE seoclass-clstype.
          SELECT SINGLE clstype FROM seoclass INTO l_clstype
                WHERE clsname = l_ddictype.
          IF sy-subrc = 0.
            IF l_clstype = 0.
              l_object = 'CLAS'.
            ELSE.
              l_object = 'INTF'.
            ENDIF.
          ENDIF.
        ENDIF.
        IF l_object IS NOT INITIAL.
          ls_e071_key-pgmid    = 'R3TR'.
          ls_e071_key-object   = l_object.
          ls_e071_key-obj_name = l_ddictype.
          mac_collect is_e071_key 'H' '' ls_e071_key.
        ENDIF.
      ELSE.
        l_remain = l_remain+3. "remove TY:
        DATA ls_dd03p TYPE dd03p.
        SELECT SINGLE * FROM dd03l INTO CORRESPONDING FIELDS OF ls_dd03p
              WHERE tabname = l_ddictype
                AND fieldname = l_remain
                AND as4local = 'A'
                AND as4vers = 0.
        IF sy-subrc = 0.
          CALL METHOD tablstruc_field
            EXPORTING
              is_dd03p    = ls_dd03p
              is_e071_key = is_e071_key.
        ENDIF.
      ENDIF.
* Note: we don't want to know if data/type comes from a type-pool
* because it's a little bit complex (DA and TY); instead, we use the
* type-pools declarations referenced in CROSS table (see below)
    ENDLOOP.

* Note: cross-name = "?" for objects dynamically called.
    SELECT * FROM cross
        INTO TABLE lt_cross
        WHERE include = i_include
          AND name    NE '?'.

    LOOP AT lt_cross ASSIGNING <ls_cross>.
      CASE <ls_cross>-type.

        WHEN 'B'.
          ls_wbobj_key-object = 'DYNP'.
          ls_wbobj_key-s_dynp-screen_number = <ls_cross>-prog.
          ls_wbobj_key-s_dynp-program_name = <ls_cross>-include.
          CALL METHOD lcl_convert_wbobj_key_2_e071=>execute
            EXPORTING
              is_wbobj_key = ls_wbobj_key
            CHANGING
              es_e071_key  = ls_e071_key.
          mac_collect is_e071_key 'H' '' ls_e071_key.

* CALL FUNCTION.
*   R3TR FUGR - LIMU FUNC
*   R3TR ENQU ( LOCK OBJECTS )
        WHEN 'F'.

          IF <ls_cross>-name(9) = 'ENQUEUE_E'
                  OR <ls_cross>-name(9) = 'DEQUEUE_E'.
            ls_e071_key-pgmid    = 'R3TR'.
            ls_e071_key-object   = 'ENQU'.
            ls_e071_key-obj_name = <ls_cross>-name+8.
            mac_collect is_e071_key 'H' '' ls_e071_key.
          ELSE.
            ls_e071_key-pgmid    = 'LIMU'.
            ls_e071_key-object   = 'FUNC'.
            ls_e071_key-obj_name = <ls_cross>-name.
            mac_collect is_e071_key 'H' '' ls_e071_key.
          ENDIF.

* TYPE-POOLS
        WHEN 'G'.
          ls_e071_key-pgmid    = 'R3TR'.
          ls_e071_key-object   = 'TYPE'.
          ls_e071_key-obj_name = <ls_cross>-name.
          mac_collect is_e071_key 'H' '' ls_e071_key.

* MESSAGE NUMBER
*   R3TR MSAG
*   LIMU MESS
        WHEN 'N'.
          ls_e071_key-pgmid    = 'R3TR'.
          ls_e071_key-object   = 'MSAG'.
          ls_e071_key-obj_name = <ls_cross>-name(20).
          mac_collect is_e071_key 'H' '' ls_e071_key.
          IF NOT <ls_cross>-name+20(3) IS INITIAL.
            ls_wbobj_key-object = 'MESS'.
            ls_wbobj_key-s_mess-msg_number = <ls_cross>-name+20(3).
            ls_wbobj_key-s_mess-msg_class_name = <ls_cross>-name(20).
            CALL METHOD lcl_convert_wbobj_key_2_e071=>execute
              EXPORTING
                is_wbobj_key = ls_wbobj_key
              CHANGING
                es_e071_key  = ls_e071_key.
            mac_collect is_e071_key 'H' '' ls_e071_key.
          ENDIF.

* SEARCH HELP (M = in dynpro, V = in program).
*   R3TR SHLD or R3TR SHLP
        WHEN 'M' OR 'V'.
          ls_e071_key-object   = 'SHLP'.
          ls_e071_key-obj_name = <ls_cross>-name.
          mac_collect is_e071_key 'H' '' ls_e071_key.

* GET PARAMETER or SET PARAMETER
        WHEN 'P'.
          ls_e071_key-object   = 'PARA'.
          ls_e071_key-obj_name = <ls_cross>-name.
          mac_collect is_e071_key 'H' '' ls_e071_key.

* SUBMIT
        WHEN 'R'.
          ls_e071_key-object   = 'PROG'.
          ls_e071_key-obj_name = <ls_cross>-name.
          mac_collect is_e071_key 'H' '' ls_e071_key.

*
        WHEN 'S'.
          ls_e071_key-object   = 'TABL'.
          ls_e071_key-obj_name = <ls_cross>-name.
          mac_collect is_e071_key 'H' '' ls_e071_key.

* CALL TRANSACTION
        WHEN 'T'.
          ls_e071_key-pgmid    = 'R3TR'.
          ls_e071_key-object   = 'TRAN'.
          ls_e071_key-obj_name = <ls_cross>-name.
          mac_collect is_e071_key 'H' '' ls_e071_key.

* PERFORM cross-name IN PROGRAM cross-prog
        WHEN 'U'.
          ls_e071_key-object   = 'PROG'.
          ls_e071_key-obj_name = <ls_cross>-prog.
          mac_collect is_e071_key 'H' '' ls_e071_key.

      ENDCASE.

    ENDLOOP.

  ENDMETHOD.                    "get_include_required_objects

  METHOD get_reqobj.
    DATA ls_e071_key TYPE type_s_e071_objkey.
    DATA ls_wbobj_key TYPE
lcl_convert_wbobj_key_2_e071=>type_s_wbobj_key.
    DATA lt_dd03p TYPE TABLE OF dd03p.
    FIELD-SYMBOLS <ls_dd03p> TYPE dd03p.
    DATA lt_dd08v TYPE TABLE OF dd08v.
    FIELD-SYMBOLS <ls_dd08v> TYPE dd08v.
    DATA lt_dd35v TYPE TABLE OF dd35v.
    FIELD-SYMBOLS <ls_dd35v> TYPE dd35v.
    DATA l_domname TYPE ddobjname.
    DATA l_rollname TYPE ddobjname.
    DATA l_devclass TYPE tadir-devclass.
    DATA l_progname TYPE syrepid.
    DATA l_include TYPE trdir-name.
    DATA l_subc TYPE trdir-subc.
    DATA l_lockobject TYPE ddobjname.
    DATA ls_dd01v TYPE dd01v.
    DATA ls_dd04v TYPE dd04v.
    DATA ls_dd30v TYPE dd30v.
    DATA l_shlpname TYPE ddobjname.
    DATA l_object TYPE e071-object.
    DATA ls_dd25v TYPE dd25v.
    DATA ls_e071 TYPE e071.
    DATA ls_tadir TYPE tadir.
    DATA l_ddobjname TYPE ddobjname.
    DATA lt_dd26v TYPE TABLE OF dd26v.
    DATA ls_dd26v TYPE dd26v.

    ls_e071_key = is_e071_key.

    REFRESH et_e071_key.
    REFRESH gt_e071_key.

    DATA ls_ko100 TYPE ko100.
    CALL FUNCTION 'TR_GET_PGMID_FOR_OBJECT'
      EXPORTING
        iv_object      = ls_e071_key-object
      IMPORTING
        es_type        = ls_ko100
      EXCEPTIONS
        illegal_object = 1
        OTHERS         = 2.
    IF sy-subrc = 0.
      ls_e071_key-pgmid = ls_ko100-pgmid.
    ENDIF.


    MOVE-CORRESPONDING is_e071_key TO ls_e071.
    CALL METHOD lcl_sap_fm_tr_check_type=>execute
      EXPORTING
        wi_e071  = ls_e071
      IMPORTING
        we_tadir = ls_tadir.

    SELECT SINGLE devclass FROM tadir INTO l_devclass
          WHERE pgmid     = ls_tadir-pgmid
            AND object    = ls_tadir-object
            AND obj_name  = ls_tadir-obj_name.
    IF sy-subrc = 0.
      ls_e071_key-pgmid    = 'R3TR'.
      ls_e071_key-object   = 'DEVC'.
      ls_e071_key-obj_name = l_devclass.
      mac_collect is_e071_key 'S' '' ls_e071_key.
    ENDIF.

* Add main program
*  LIMU METH YYYY  XXXX -> Add R3TR CLAS YYYY
*  LIMU DYNP YYYY     XXXX -> Add R3TR PROG YYYY
*  LIMU DYNP SAPLYYYY XXXX -> Add R3TR FUGR YYYY
*  LIMU MESS YYYY  XXX -> Add R3TR MSAG YYYY
* etc.
    IF is_e071_key-pgmid = 'LIMU'.
      ls_e071_key-pgmid    = ls_tadir-pgmid.
      ls_e071_key-object   = ls_tadir-object.
      ls_e071_key-obj_name = ls_tadir-obj_name.
      mac_collect is_e071_key 'H' '' ls_e071_key.
    ENDIF.

    ls_e071_key = is_e071_key.

    CASE ls_e071_key-object.
*---------------------
* DEVELOPMENT CLASS
*---------------------
      WHEN 'DEVC'.
        DATA l_package_name TYPE devclass.
        l_package_name = is_e071_key-obj_name.
        CALL METHOD get_devc_required_objects
          EXPORTING
            i_package_name = l_package_name.

*---------------------
* transaction code
*---------------------
      WHEN 'TRAN'.

        DATA l_tcode TYPE tcode.
        DATA lo_transaction TYPE REF TO lcl_tran.

        l_tcode = is_e071_key-obj_name.
        CREATE OBJECT lo_transaction
          EXPORTING
            i_tcode = l_tcode.

        CASE lo_transaction->type.
          WHEN 'O'.
            IF lo_transaction->s_object-local_class = 'X'.
              ls_e071_key-pgmid    = 'R3TR'.
              ls_e071_key-object   = 'PROG'.
              ls_e071_key-obj_name =
lo_transaction->s_object-program_name.
              mac_collect is_e071_key 'H' '' ls_e071_key.
            ELSE.
              ls_e071_key-pgmid   = 'LIMU'.
              ls_wbobj_key-object = 'METH'.
              ls_wbobj_key-s_meth-method_name =
lo_transaction->s_object-method_name.
              ls_wbobj_key-s_meth-class_name =
lo_transaction->s_object-global_class_name.
              CALL METHOD lcl_convert_wbobj_key_2_e071=>execute
                EXPORTING
                  is_wbobj_key = ls_wbobj_key
                CHANGING
                  es_e071_key  = ls_e071_key.
              mac_collect is_e071_key 'H' '' ls_e071_key.
            ENDIF.
            IF NOT lo_transaction->s_object-auth_object IS INITIAL.
              ls_e071_key-pgmid    = 'R3TR'.
              ls_e071_key-object   = 'SUSO'.
              ls_e071_key-obj_name =
lo_transaction->s_object-auth_object.
              mac_collect is_e071_key 'H' '' ls_e071_key.
            ENDIF.
          WHEN 'D'.
            ls_e071_key-pgmid = 'LIMU'.
            ls_wbobj_key-object = 'DYNP'.
            ls_wbobj_key-s_dynp-program_name =
lo_transaction->s_dialog-program_name.
            ls_wbobj_key-s_dynp-screen_number =
lo_transaction->s_dialog-screen_number.
            CALL METHOD lcl_convert_wbobj_key_2_e071=>execute
              EXPORTING
                is_wbobj_key = ls_wbobj_key
              CHANGING
                es_e071_key  = ls_e071_key.
            mac_collect is_e071_key 'H' '' ls_e071_key.
            IF NOT lo_transaction->s_dialog-auth_object IS INITIAL.
              ls_e071_key-pgmid    = 'R3TR'.
              ls_e071_key-object   = 'SUSO'.
              ls_e071_key-obj_name =
lo_transaction->s_dialog-auth_object.
              mac_collect is_e071_key 'H' '' ls_e071_key.
            ENDIF.
          WHEN 'P'.
            IF NOT lo_transaction->s_parameter-called_tcode IS INITIAL.
              ls_e071_key-pgmid    = 'R3TR'.
              ls_e071_key-object   = 'TRAN'.
              ls_e071_key-obj_name =
lo_transaction->s_parameter-called_tcode.
              mac_collect is_e071_key 'H' '' ls_e071_key.
            ENDIF.
            IF NOT lo_transaction->s_parameter-program_name IS INITIAL.
              ls_e071_key-pgmid   = 'LIMU'.
              ls_wbobj_key-object = 'DYNP'.
              ls_wbobj_key-s_dynp-program_name =
lo_transaction->s_parameter-program_name.
              ls_wbobj_key-s_dynp-screen_number =
lo_transaction->s_parameter-screen_number.
              CALL METHOD lcl_convert_wbobj_key_2_e071=>execute
                EXPORTING
                  is_wbobj_key = ls_wbobj_key
                CHANGING
                  es_e071_key  = ls_e071_key.
              mac_collect is_e071_key 'H' '' ls_e071_key.
            ENDIF.
          WHEN 'V'.
            ls_e071_key-pgmid    = 'R3TR'.
            ls_e071_key-object   = 'TRAN'.
            ls_e071_key-obj_name =
lo_transaction->s_variant-called_tcode.
            mac_collect is_e071_key 'H' '' ls_e071_key.
            IF NOT lo_transaction->s_variant-transac_variant IS INITIAL.
              ls_e071_key-object   = 'STVI'.
              ls_e071_key-obj_name =
lo_transaction->s_variant-transac_variant.
              mac_collect is_e071_key 'H' '' ls_e071_key.
            ENDIF.
          WHEN 'R'.
            ls_e071_key-pgmid    = 'R3TR'.
            ls_e071_key-object   = 'PROG'.
            ls_e071_key-obj_name =
lo_transaction->s_report-program_name.
            mac_collect is_e071_key 'H' '' ls_e071_key.
            IF NOT lo_transaction->s_report-auth_object IS INITIAL.
              ls_e071_key-pgmid    = 'R3TR'.
              ls_e071_key-object   = 'SUSO'.
              ls_e071_key-obj_name =
lo_transaction->s_report-auth_object.
              mac_collect is_e071_key 'H' '' ls_e071_key.
            ENDIF.
            IF NOT lo_transaction->s_report-program_variant IS INITIAL.
              ls_e071_key-pgmid   = 'LIMU'.
* TODO : could be also VARX (&CUS...)
              ls_wbobj_key-object = 'VARI'.
              ls_wbobj_key-s_vari-program_name =
lo_transaction->s_report-program_name.
              ls_wbobj_key-s_vari-variant_name =
lo_transaction->s_report-program_variant.
              CALL METHOD lcl_convert_wbobj_key_2_e071=>execute
                EXPORTING
                  is_wbobj_key = ls_wbobj_key
                CHANGING
                  es_e071_key  = ls_e071_key.
              mac_collect is_e071_key 'H' '' ls_e071_key.
            ENDIF.
        ENDCASE.

*---------------------
* ENHANCEMENT Implementation
*---------------------
      WHEN 'ENHO'.
        DATA lo_enh TYPE REF TO if_enh_tool.
        DATA lo_enh2 TYPE REF TO cl_enh_tool_hook_impl.
        DATA lo_enh99 TYPE REF TO cl_enh_tool_clif.
        DATA l_enhname TYPE enhname.
        DATA lt_enhobj TYPE TABLE OF enhobj.
        DATA ls_enhobj TYPE enhobj.
        DATA l_tool_type TYPE enhtooltype.

        l_enhname = is_e071_key-obj_name.

        lo_enh = cl_enh_factory=>get_enhancement( enhancement_id =
l_enhname ).
        l_tool_type = lo_enh->get_tool( ).

* For a badi, we'll get ENHS, CLAS, INTF.
* For a hook, we'll get the main program (FUGR or PROG or CLAS)
* For a class enh, we'll get the class name (+ its interfaces + its
*   superclasses up to top class) and the enhanced methods (new
*parameters)
* For a function group enh, we'll get the function group and the
*enhanced
*   function module (new parameters)
        SELECT * FROM enhobj INTO TABLE lt_enhobj
          WHERE enhname = l_enhname.
        LOOP AT lt_enhobj INTO ls_enhobj.
          ls_e071_key-pgmid    = 'R3TR'.
          ls_e071_key-object   = ls_enhobj-obj_type.
          ls_e071_key-obj_name = ls_enhobj-obj_name.
          mac_collect is_e071_key 'H' '' ls_e071_key.
        ENDLOOP.

        CASE l_tool_type.
****
          WHEN 'HOOK_IMPL'.
            lo_enh2 ?= lo_enh.
            CALL METHOD lo_enh2->get_hook_impls_include
              IMPORTING
                include = l_include.
            CALL METHOD get_include_required_objects
              EXPORTING
                i_include = l_include.

****
          WHEN 'CLASENH'.
            lo_enh99 ?= lo_enh.
            CALL METHOD lo_enh99->get_include_name
              IMPORTING
                include = l_include.
            CALL METHOD get_include_required_objects
              EXPORTING
                i_include = l_include.
****
          WHEN 'FUGRENH'.
            lo_enh99 ?= lo_enh.
            CALL METHOD lo_enh99->get_include_name
              IMPORTING
                include = l_include.
            CALL METHOD get_include_required_objects
              EXPORTING
                i_include = l_include.
**** TODO
          WHEN 'BADI_IMPL'.
*            lo_enh5 ?= lo_enh.
*          DATA lt_impl TYPE enh_badi_impl_data_it.
*          DATA ls_impl TYPE LINE OF enh_badi_impl_data_it.
*          lt_impl = lo_enh5->get_implementations( ).
*          LOOP AT lt_impl INTO ls_impl.
**            ls_e071_key-pgmid    = 'R3TR'.
**            ls_e071_key-object   = 'SXCI'.
**            ls_e071_key-obj_name = ls_impl-impl_name.
**            mac_collect is_e071_key 'H' '' ls_e071_key.
*            ls_e071_key-pgmid    = 'R3TR'.
*            ls_e071_key-object   = 'INTF'.
*            CONCATENATE 'IF_EX_' ls_impl-impl_name INTO
*ls_e071_key-obj_name.
*            mac_collect is_e071_key 'H' '' ls_e071_key.
*            ls_e071_key-pgmid    = 'R3TR'.
*            ls_e071_key-object   = 'CLAS'.
*            ls_e071_key-obj_name = ls_impl-impl_class.
*            mac_collect is_e071_key 'H' '' ls_e071_key.
*          ENDLOOP.

**** TODO
          WHEN 'INTFENH'.
*            lo_enh6 ?= lo_enh.

**** TODO
          WHEN 'WDYENH'.
*            lo_enh7 ?= lo_enh.
        ENDCASE.

*---------------------
* PROGRAM
*---------------------
      WHEN 'PROG' OR 'REPS' OR 'REPO'.
        CASE ls_e071_key-object.
          WHEN 'REPS' OR 'REPO'.
            SELECT SINGLE subc FROM trdir INTO l_subc WHERE name =
l_progname.
            CASE l_subc.
              WHEN '1' OR 'M' OR 'F' OR 'S' OR 'K'.
                ls_e071_key-pgmid    = 'LIMU'.
                ls_e071_key-object   = 'REPT'.
                ls_e071_key-obj_name = is_e071_key-obj_name.
                mac_collect is_e071_key 'H' '' ls_e071_key.
            ENDCASE.
        ENDCASE.
        l_include = is_e071_key-obj_name.
        CALL METHOD get_include_required_objects
          EXPORTING
            i_include = l_include.

*---------------------
* interface
*---------------------
      WHEN 'INTF' OR 'INTD'.
        DATA l_interface_name TYPE seoclass-clsname.
        l_interface_name = is_e071_key-obj_name.
        CALL FUNCTION 'RS_PROGNAME_CONCATENATE'
          EXPORTING
            intf_name       = l_interface_name
          IMPORTING
            intf_progname   = l_include
          EXCEPTIONS
            delimiter_error = 1
            OTHERS          = 2.
        CALL METHOD get_include_required_objects
          EXPORTING
            i_include = l_include.

*---------------------
* class
*---------------------
      WHEN 'CLAS'.
        DATA l_class_name TYPE seoclass-clsname.
        l_class_name = is_e071_key-obj_name.
        CALL FUNCTION 'RS_PROGNAME_CONCATENATE'
          EXPORTING
            clas_name       = l_class_name
          IMPORTING
            clas_progname   = l_include
          EXCEPTIONS
            delimiter_error = 1
            OTHERS          = 2.
        IF sy-subrc = 0.
          CALL METHOD get_include_required_objects
            EXPORTING
              i_include = l_include.
        ENDIF.

*---------------------
* method
*---------------------
      WHEN 'METH'.
        CALL METHOD get_include_required_objects
          EXPORTING
            i_include = ls_wbobj_key-include.

*---------------------
* function
*---------------------
      WHEN 'FUNC'.
        CALL METHOD get_include_required_objects
          EXPORTING
            i_include = ls_wbobj_key-include.

*---------------------
* TYPE-POOL
*---------------------
      WHEN 'TYPE' OR 'TYPD'.
        DATA l_type_name TYPE trdir-name.
        l_type_name = is_e071_key-obj_name.
        CALL FUNCTION 'RS_PROGNAME_CONCATENATE'
          EXPORTING
            type_name       = l_type_name
          IMPORTING
            type_progname   = l_include
          EXCEPTIONS
            delimiter_error = 1
            OTHERS          = 2.
        CALL METHOD get_include_required_objects
          EXPORTING
            i_include = l_include.

*---------------------
* FUNCTION GROUP
*---------------------
      WHEN 'FUGT'.
        ls_e071_key-pgmid    = 'R3TR'.
        ls_e071_key-object   = 'FUGR'.
        ls_e071_key-obj_name = is_e071_key-obj_name.
        mac_collect is_e071_key 'H' '' ls_e071_key.
      WHEN 'FUGR'.
        DATA l_function_group TYPE rs38l-area.
        l_function_group = is_e071_key-obj_name.
        CALL FUNCTION 'RS_PROGNAME_CONCATENATE'
          EXPORTING
            fugr_group          = l_function_group
          IMPORTING
            fugr_progname_group = l_include
          EXCEPTIONS
            delimiter_error     = 1
            OTHERS              = 2.
        IF sy-subrc = 0.
          CALL METHOD get_include_required_objects
            EXPORTING
              i_include = l_include.
        ENDIF.

*---------------------
* TABLE or STRUCTURE
*---------------------
      WHEN 'TABT'.
        ls_e071_key-pgmid    = 'R3TR'.
        ls_e071_key-object   = 'TABL'.
        ls_e071_key-obj_name = is_e071_key-obj_name.
        mac_collect is_e071_key 'H' '' ls_e071_key.
      WHEN 'TABL' OR 'TABD'.
        DATA l_name TYPE ddobjname.
        l_name = is_e071_key-obj_name.
        CALL FUNCTION 'DDIF_TABL_GET'
          EXPORTING
            name          = l_name
          TABLES
            dd03p_tab     = lt_dd03p
            dd08v_tab     = lt_dd08v
            dd35v_tab     = lt_dd35v
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc = 0.
* Fields : data elements, domaines, tables de contrï¿½les
          LOOP AT lt_dd03p ASSIGNING <ls_dd03p>.
            CALL METHOD tablstruc_field
              EXPORTING
                is_dd03p    = <ls_dd03p>
                is_e071_key = is_e071_key.

            IF NOT <ls_dd03p>-checktable IS INITIAL.
              ls_e071_key-pgmid    = 'R3TR'.
              ls_e071_key-object   = 'TABL'.
              ls_e071_key-obj_name = <ls_dd03p>-checktable.
              mac_collect is_e071_key 'H' '' ls_e071_key.
            ENDIF.
          ENDLOOP.
* Foreign keys
          LOOP AT lt_dd08v ASSIGNING <ls_dd08v>.
            ls_e071_key-pgmid    = 'R3TR'.
            ls_e071_key-object   = 'TABL'.
            ls_e071_key-obj_name = <ls_dd08v>-checktable.
            mac_collect is_e071_key 'H' '' ls_e071_key.
          ENDLOOP.
* Search helps
          LOOP AT lt_dd35v ASSIGNING <ls_dd35v>.
            IF NOT <ls_dd35v>-shlpname IS INITIAL.
              ls_e071_key-pgmid    = 'R3TR'.
              ls_e071_key-object   = 'SHLP'.
              ls_e071_key-obj_name = <ls_dd35v>-shlpname.
              mac_collect is_e071_key 'H' '' ls_e071_key.
            ENDIF.
          ENDLOOP.
        ENDIF.

*---------------------
* VIEW
*---------------------
      WHEN 'VIEW' OR 'VIED'.
        l_lockobject = is_e071_key-obj_name.
        CALL FUNCTION 'DDIF_VIEW_GET'
          EXPORTING
            name          = l_ddobjname
          IMPORTING
            dd25v_wa      = ls_dd25v
          TABLES
            dd26v_tab     = lt_dd26v
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc = 0.
          LOOP AT lt_dd26v INTO ls_dd26v.
            ls_e071_key-pgmid    = 'R3TR'.
            ls_e071_key-object   = 'TABL'.
            ls_e071_key-obj_name = ls_dd26v-tabname.
            mac_collect is_e071_key 'H' '' ls_e071_key.
          ENDLOOP.
        ENDIF.

*---------------------
* TABLE TYPE
*---------------------
      WHEN 'TTYP' OR 'TTYD'.
        l_ddobjname = is_e071_key-obj_name.
        DATA ls_dd40v TYPE dd40v.
        CALL FUNCTION 'DDIF_TTYP_GET'
          EXPORTING
            name          = l_ddobjname
          IMPORTING
            dd40v_wa      = ls_dd40v
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc = 0.
          ls_e071_key-pgmid    = 'R3TR'.
          CALL METHOD lcl_sap_fm_ddif_typeinfo_get=>execute
            EXPORTING
              i_tabname = ls_dd40v-rowtype
            CHANGING
              e_object  = ls_e071_key-object.
          ls_e071_key-obj_name = ls_dd40v-rowtype.
          mac_collect is_e071_key 'H' '' ls_e071_key.
        ENDIF.

*---------------------
* DATA ELEMENT
*---------------------
      WHEN 'DTEL' OR 'DTED'.
        l_rollname = is_e071_key-obj_name.
        DATA ls_tpara TYPE tpara.
        CALL FUNCTION 'DDIF_DTEL_GET'
          EXPORTING
            name          = l_rollname
          IMPORTING
            dd04v_wa      = ls_dd04v
            tpara_wa      = ls_tpara
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc = 0.
          IF NOT ls_dd04v-domname IS INITIAL.
            ls_e071_key-pgmid    = 'R3TR'.
            ls_e071_key-object   = 'DOMA'.
            ls_e071_key-obj_name = ls_dd04v-domname.
            mac_collect is_e071_key 'H' '' ls_e071_key.
          ENDIF.
          IF NOT ls_dd04v-shlpname IS INITIAL.
            ls_e071_key-pgmid    = 'R3TR'.
            ls_e071_key-object   = 'SHLP'.
            ls_e071_key-obj_name = ls_dd04v-shlpname.
            mac_collect is_e071_key 'H' '' ls_e071_key.
          ENDIF.
          IF NOT ls_tpara-paramid IS INITIAL.
            ls_e071_key-pgmid    = 'R3TR'.
            ls_e071_key-object   = 'PARA'.
            ls_e071_key-obj_name = ls_tpara-paramid.
            mac_collect is_e071_key 'H' '' ls_e071_key.
          ENDIF.
        ENDIF.

*---------------------
* DOMAIN
*---------------------
      WHEN 'DOMA' OR 'DOMD'.
        l_domname = is_e071_key-obj_name.
        CALL FUNCTION 'DDIF_DOMA_GET'
          EXPORTING
            name          = l_domname
          IMPORTING
            dd01v_wa      = ls_dd01v
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc = 0.
          IF NOT ls_dd01v-entitytab IS INITIAL.
            ls_e071_key-pgmid    = 'R3TR'.
            ls_e071_key-object   = 'TABL'.
            ls_e071_key-obj_name = ls_dd01v-entitytab.
            mac_collect is_e071_key 'H' '' ls_e071_key.
          ENDIF.
        ENDIF.

*---------------------
* SEARCH HELP
*---------------------
      WHEN 'SHLP' OR 'SHLD'.
        l_shlpname = is_e071_key-obj_name.
        CALL FUNCTION 'DDIF_SHLP_GET'
          EXPORTING
            name          = l_shlpname
          IMPORTING
            dd30v_wa      = ls_dd30v
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc = 0.
          IF NOT ls_dd30v-selmethod IS INITIAL.
            CALL METHOD lcl_sap_fm_ddif_typeinfo_get=>execute
              EXPORTING
                i_tabname = ls_dd30v-selmethod
              CHANGING
                e_object  = l_object.
            ls_e071_key-object   = l_object.
            ls_e071_key-obj_name = ls_dd30v-selmethod.
            mac_collect is_e071_key 'H' '' ls_e071_key.
          ENDIF.
          IF NOT ls_dd30v-texttab IS INITIAL.
            ls_e071_key-pgmid    = 'R3TR'.
            ls_e071_key-object   = 'TABL'.
            ls_e071_key-obj_name = ls_dd30v-texttab.
            mac_collect is_e071_key 'H' '' ls_e071_key.
          ENDIF.
        ENDIF.

*---------------------
* LOCK OBJECT
*---------------------
      WHEN 'ENQU'.
        l_lockobject = is_e071_key-obj_name.
        CALL FUNCTION 'DDIF_ENQU_GET'
          EXPORTING
            name          = l_lockobject
          IMPORTING
            dd25v_wa      = ls_dd25v
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc = 0.
          ls_e071_key-pgmid    = 'R3TR'.
          ls_e071_key-object   = 'TABL'.
          ls_e071_key-obj_name = ls_dd25v-roottab.
          mac_collect is_e071_key 'H' '' ls_e071_key.
        ENDIF.

    ENDCASE.

    et_e071_key = gt_e071_key.

  ENDMETHOD.                    "get_obj

*&---------------------------------------------------------------------*
*----------------------------------------------------------------------*
  METHOD tablstruc_field.
    DATA ls_e071_key TYPE type_s_e071_objkey.

    IF is_dd03p-fieldname = '.APPEND_DU'.
* .APPEND_DU indicates a recurse structure, PRECFIELD is empty, ignore
*it

    ELSEIF is_dd03p-fieldname = '.APPEND'
          OR is_dd03p-fieldname(6) = '.INCLU'.
* .INCLU-*** indicates include with suffix *** for components
      ls_e071_key-pgmid    = 'R3TR'.
      ls_e071_key-object   = 'TABL'.
      ls_e071_key-obj_name = is_dd03p-precfield.
      IF is_dd03p-precfield CP 'CI_*'
            OR is_dd03p-precfield CP 'SI_*'.
* activation won't fail if the CI_* include doesn't exist
        mac_collect is_e071_key 'S' '' ls_e071_key.
      ELSE.
* activation will fail if other includes don't exist
        mac_collect is_e071_key 'H' '' ls_e071_key.
      ENDIF.
* components with intern type / length have COMPTYPE = blank
* (don't test ROLLNAME which sometimes is not blank)
    ELSEIF NOT is_dd03p-comptype IS INITIAL.
      ls_e071_key-pgmid    = 'R3TR'.
      DATA l_link TYPE c LENGTH 1.
      l_link = 'H'.
      CASE is_dd03p-comptype.
        WHEN 'E'.
          ls_e071_key-object   = 'DTEL'.
        WHEN 'S'.
          ls_e071_key-object   = 'TABL'.
        WHEN 'L'.
          ls_e071_key-object   = 'TTYP'.
        WHEN 'R'. "type ref to
          CASE is_dd03p-reftype.
            WHEN 'C'.
              ls_e071_key-object   = 'CLAS'.
            WHEN 'I'.
              ls_e071_key-object   = 'INTF'.
            WHEN 'E'.
              ls_e071_key-object   = 'DTEL'.
            WHEN 'S'. "structure or table
              ls_e071_key-object   = 'TABL'.
            WHEN 'L'.
              ls_e071_key-object   = 'TTYP'.
            WHEN space. "undefined
              DATA l_typename TYPE typename.
              DATA l_typekind TYPE ddtypekind.
              l_typename = is_dd03p-rollname.
              CALL FUNCTION 'DDIF_TYPEINFO_GET'
                EXPORTING
                  typename = l_typename
                IMPORTING
                  typekind = l_typekind.
              IF l_typekind IS NOT INITIAL.
                ls_e071_key-object   = l_typekind.
              ENDIF.
            WHEN 'B'.
* reference to an internal data type, length, decimals -> IGNORE
            WHEN OTHERS.
              ASSERT is_dd03p-reftype = 'D' "data
                    OR is_dd03p-reftype = 'O'. "object
          ENDCASE.
        WHEN 'N'. "non existing structure (or inactive), i.e. CI_* or
*SI_*
          ls_e071_key-object = 'TABL'.
          l_link = 'S'. "include ci_* may not exist
        WHEN OTHERS.
          MESSAGE x001(00).
      ENDCASE.
      IF ls_e071_key-object IS NOT INITIAL.
        ls_e071_key-obj_name = is_dd03p-rollname.
        mac_collect is_e071_key l_link '' ls_e071_key.
      ENDIF.
    ENDIF.
  ENDMETHOD.                    "tablstruc_field


ENDCLASS.                    "lcl_dev_cross_ref IMPLEMENTATION
* <<< END OF INCLUDE
TYPE-POOLS icon.
PARAMETERS p_targe2 TYPE rfcdest.

* X = analyze standard programs
PARAMETERS p_incst2 TYPE flag AS CHECKBOX.

* X = ignore errors "source system is different"
PARAMETERS p_srcsy2 TYPE flag AS CHECKBOX.

TABLES e070.
SELECT-OPTIONS s_trkor2 FOR e070-trkorr.

* "time machine" : mostly used for test purposes
PARAMETERS p_timem2 TYPE tzntimestp.

* dummy screen to display the 3 result ALVs
SELECTION-SCREEN BEGIN OF SCREEN 1010.
*  parameters p_dummy.
SELECTION-SCREEN END OF SCREEN 1010.


TYPES ty_t_e071 TYPE TABLE OF e071 WITH DEFAULT KEY.

TYPES ty_result_rc TYPE i.
CONSTANTS : BEGIN OF gcs_result_rc,
              ok   TYPE ty_result_rc VALUE 0,
              warn TYPE ty_result_rc VALUE 4,
              err  TYPE ty_result_rc VALUE 8,
            END OF gcs_result_rc.
TYPES : BEGIN OF ty_s_result2,
          object      TYPE lcl_dev_cross_ref=>type_s_e071_objkey,
        END OF ty_s_result2.
TYPES : BEGIN OF ty_s_result,
          object        TYPE lcl_dev_cross_ref=>type_s_e071_objkey,
          trkorr        TYPE e070-trkorr,
          rc            TYPE ty_result_rc,
          icon          TYPE icon_d,
          message       TYPE string,
        END OF ty_s_result.
* 2010-11-22 scope of local lt_result2 variable from DISPLAY_RESULT
* subroutine, changed into global (bug found by Kihoori Oct 21)
* List of required objects + by which object(s) are they required
TYPES : BEGIN OF ty_gs_result2,
          object    TYPE lcl_dev_cross_ref=>type_s_e071_objkey,
          rc        TYPE ty_result_rc,
          subobject TYPE lcl_dev_cross_ref=>type_s_e071_objkey,
        END OF ty_gs_result2.

******************************
*CLASS lcl_salv_handler DEFINITION.
*  PUBLIC SECTION.
*    METHODS react_to_double_click
*          FOR EVENT double_click
*          OF cl_salv_events_table
*          IMPORTING row column.
*ENDCLASS.                    "lcl_salv_handler DEFINITION
*
******************************
*CLASS lcl_salv_handler IMPLEMENTATION.
*  METHOD react_to_double_click.
*  ENDMETHOD.                    "react_to_double_click
*ENDCLASS.                    "lcl_salv_handler IMPLEMENTATION

*****************************
CLASS lcl_sap_fm DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS tr_check_type
        IMPORTING
          wi_e071  TYPE e071
        EXPORTING
          we_lock_key TYPE tlock_int
          we_tadir TYPE tadir.
ENDCLASS.                    "lcl_sap_fm DEFINITION

*----------------------------------------------------------------------*
TYPES : BEGIN OF type_s_docu_key,
          docu_id      TYPE dokhl-id,
          docu_object  TYPE dokhl-object,
        END OF type_s_docu_key.
TYPES : BEGIN OF type_s_tobj_key,
          objectname   TYPE objh-objectname,
          objecttype   TYPE objh-objecttype,
        END OF type_s_tobj_key.
TYPES : BEGIN OF type_s_sott_key,
          paket        TYPE sotr_pack,
          concept      TYPE sotr_conc,
        END OF type_s_sott_key.
TYPES type_spad(5) TYPE c.
TYPES : BEGIN OF type_s_spcs_key,
          spad_type TYPE type_spad,
          codepage  TYPE tcp00-cpcodepage,
        END OF type_s_spcs_key.
TYPES : BEGIN OF type_s_spsv_key,
          spad_type  TYPE type_spad,
          server     TYPE tspsv-server,
        END OF type_s_spsv_key.
TYPES : BEGIN OF type_s_spdv_key,
          spad_type  TYPE type_spad,
          device     TYPE tsp03-padest,
        END OF type_s_spdv_key.
TYPES : BEGIN OF type_s_splo_key,
          spad_type     TYPE type_spad,
          paper_format  TYPE tsp1d-papart,
        END OF type_s_splo_key.
TYPES : BEGIN OF type_s_prin_key,
          spad_type     TYPE type_spad,
          printer_type  TYPE tsp0a-patype,
        END OF type_s_prin_key.
TYPES : BEGIN OF type_s_slom_key,
          spad_type              TYPE type_spad,
          logical_output_system  TYPE tsploms-name,
        END OF type_s_slom_key.
TYPES : BEGIN OF type_s_soms_key,
          spad_type          TYPE type_spad,
          read_output_system TYPE tsproms-name,
        END OF type_s_soms_key.
TYPES : BEGIN OF type_s_scp_key,
          bcset_id TYPE scpr_id,
          category TYPE scpr_ctgry,
        END OF type_s_scp_key.
TYPES : BEGIN OF type_s_dynp_key,
          program_name   TYPE d020s-prog,
          screen_number  TYPE d020s-dnum,
        END OF type_s_dynp_key.
TYPES : BEGIN OF type_s_vari_key,
          variant_name TYPE vari-variant,
          program_name TYPE vari-report,
        END OF type_s_vari_key.
TYPES : BEGIN OF type_s_mess_key,
          msg_class_name  TYPE t100-arbgb,
          msg_number      TYPE t100-msgnr,
        END OF type_s_mess_key.
TYPES : BEGIN OF type_s_meth_key,
          class_name   TYPE seoclsname,
          method_name  TYPE seocpdname,
        END OF type_s_meth_key.
TYPES : BEGIN OF type_s_wdyc_key,
          webdynpro_name    TYPE wdy_component_name,
          controller_name   TYPE wdy_controller_name,
        END OF type_s_wdyc_key.
TYPES : BEGIN OF type_s_wdyv_key,
          webdynpro_name    TYPE wdy_component_name,
          view_name         TYPE wdy_view_name,
        END OF type_s_wdyv_key.
TYPES : BEGIN OF type_s_wapp_key,
          appl_name     TYPE o2applname,
          page_name     TYPE o2page,
        END OF type_s_wapp_key.

TYPES : BEGIN OF type_s_wbobj_key,
          obj_name   TYPE e071-obj_name,
          object     TYPE e071-object,
          s_docu     TYPE type_s_docu_key,
          include    TYPE progname,
          trkorr     TYPE trkorr,
          s_tobj     TYPE type_s_tobj_key,
          s_sott     TYPE type_s_sott_key,
          s_spcs     TYPE type_s_spcs_key,
          s_spsv     TYPE type_s_spsv_key,
          s_spdv     TYPE type_s_spdv_key,
          s_splo     TYPE type_s_splo_key,
          s_prin     TYPE type_s_prin_key,
          s_slom     TYPE type_s_slom_key,
          s_soms     TYPE type_s_soms_key,
          s_scp      TYPE type_s_scp_key,
          file       TYPE cts_guid32,
          s_dynp     TYPE type_s_dynp_key,
          s_vari     TYPE type_s_vari_key,
          s_mess     TYPE type_s_mess_key,
          s_meth     TYPE type_s_meth_key,
          s_wdyc     TYPE type_s_wdyc_key,
          s_wdyv     TYPE type_s_wdyv_key,
          s_wapp     TYPE type_s_wapp_key,
        END OF type_s_wbobj_key.


TYPES : BEGIN OF ty_s_request,
          sort  TYPE numc4,
          icon  TYPE icon_d,
          e070  TYPE e070,
        END OF ty_s_request.
TYPES soft_or_hard TYPE c LENGTH 1.
TYPES : BEGIN OF type_s_e071_rel,
          request   TYPE ty_s_request,
          object    TYPE lcl_dev_cross_ref=>type_s_e071_objkey,
          soft_or_hard TYPE soft_or_hard,
          mmmm      TYPE flag,
          subrequest TYPE ty_s_request,
          subobject TYPE lcl_dev_cross_ref=>type_s_e071_objkey,
        END OF type_s_e071_rel.

TYPES type_t_e071_key TYPE SORTED TABLE OF
lcl_dev_cross_ref=>type_s_e071_objkey
      WITH UNIQUE KEY
        pgmid object obj_name.

TYPES gtyp_t_e071 TYPE TABLE OF e071.
TYPES ty_t_trkorr TYPE TABLE OF e070-trkorr.


*----------------------------------------------------------------------*
CLASS lcl_tra_sim DEFINITION.
  PUBLIC SECTION.
    TYPES ty_ut_rng_trkorr TYPE RANGE OF e070-trkorr.
    DATA p_target TYPE rfcdest READ-ONLY.
    DATA p_incstd TYPE flag READ-ONLY.
    DATA p_srcsys TYPE flag READ-ONLY.
    DATA s_trkorr TYPE ty_ut_rng_trkorr READ-ONLY.
    DATA p_timema TYPE tzntimestp READ-ONLY.

    METHODS constructor
          IMPORTING
            p_target TYPE rfcdest
            p_incstd TYPE flag
            p_srcsys TYPE flag
            s_trkorr TYPE ty_ut_rng_trkorr
            p_timema TYPE tzntimestp.
    METHODS main2.
    METHODS display_result.
    CLASS-METHODS is_object_custom
          IMPORTING
            i_object    TYPE tadir-object
            i_obj_name  TYPE tadir-obj_name
          RETURNING
            VALUE(r_result) TYPE abap_bool.

  PRIVATE SECTION.
    TYPES : BEGIN OF ty_is_type_of_missing,
              fullname  TYPE string,
              tabname   TYPE dd03l-tabname,
            END OF ty_is_type_of_missing.
    TYPES ty_it_type_of_missing TYPE STANDARD TABLE OF
ty_is_type_of_missing WITH DEFAULT KEY.
    DATA gt_e071_key TYPE TABLE OF type_s_e071_rel.
    DATA gt_e070_start TYPE TABLE OF e070.
    DATA gt_e071_dont_exist_in_target TYPE ty_t_e071.

    METHODS build_list_of_objects.
    METHODS get_e071_dont_exist_in_target
*          IMPORTING
*            p_target TYPE rfcdest
          EXPORTING
            et_e071 TYPE ty_t_e071.

    METHODS collect2 "-> will store it into GT_E071_KEY
          IMPORTING
            x             TYPE lcl_dev_cross_ref=>type_s_e071_objkey
"object
            soft_or_hard  TYPE soft_or_hard
            mmmm          TYPE flag
            y             TYPE lcl_dev_cross_ref=>type_s_e071_objkey
"subobject
            subrequest    TYPE ty_s_request
            force_custom  TYPE flag.
    METHODS check_exists
          IMPORTING
            ls_e071_key  TYPE lcl_dev_cross_ref=>type_s_e071_objkey
*            i_target     TYPE rfcdest
          EXPORTING
            e_not_found  TYPE flag
            e_lock       TYPE flag
            e_trkorr     TYPE e070-trkorr
            e_srcsystem_in_current TYPE tadir-srcsystem
            e_srcsystem_in_target  TYPE tadir-srcsystem.
    METHODS tablstruc_field
          IMPORTING
                is_dd03p TYPE dd03p
                is_e071_key TYPE lcl_dev_cross_ref=>type_s_e071_objkey.
    METHODS get_table_type
          IMPORTING
            i_tabname TYPE tabname
          EXPORTING
            e_object TYPE char1.
    METHODS convert_wbobj_key_into_e071
          IMPORTING
            is_wbobj_key    TYPE  type_s_wbobj_key
          EXPORTING
            es_e071_key     TYPE  lcl_dev_cross_ref=>type_s_e071_objkey.
    METHODS check_missing_fields.
* Search missing fields for all structures and tables
    METHODS get_missing_fields
          RETURNING
            value(rt_result) TYPE ty_it_type_of_missing.
* Rechercher la date et l'heure de crï¿½ation d'un objet
* en se basant sur la date du premier ordre de transport qui
* le contient
    METHODS get_creation_timestamp
          IMPORTING
            i_pgmid     TYPE e071-pgmid
            i_object    TYPE e071-object
            i_obj_name  TYPE clike
          EXPORTING
            e_timestamp TYPE tzntimestp.
    METHODS process1.
    METHODS process2.

ENDCLASS.                    "lcl_tra_sim DEFINITION
*----------------------------------------------------------------------*
DEFINE mac_collect2.
  call method collect2
    exporting
      x            = &1
      soft_or_hard = &2
      mmmm         = &3
      y            = &4
      subrequest   = &5
      force_custom = &6.
END-OF-DEFINITION.

*----------------------------------------------------------------------*

DATA: BEGIN OF gs_cluster_content,
        lastgentime  TYPE tzntimestp,
        t_e070       TYPE TABLE OF e070 WITH DEFAULT KEY,
        t_e071       TYPE ty_t_e071,
      END OF gs_cluster_content.
FIELD-SYMBOLS <ls_result2> TYPE ty_s_result2.
FIELD-SYMBOLS <ls_result> TYPE ty_s_result.
DATA gt_result TYPE TABLE OF ty_s_result.

DATA go_splitter_container TYPE REF TO cl_gui_splitter_container.
DATA go_splitter_container_2 TYPE REF TO cl_gui_container.
DATA go_container_request TYPE REF TO cl_gui_container.
DATA go_container_error TYPE REF TO cl_gui_container.
DATA go_container_requiredby TYPE REF TO cl_gui_container.
DATA go_alv_request TYPE REF TO cl_salv_table.
DATA go_alv_error TYPE REF TO cl_salv_table.
DATA go_alv_requiredby TYPE REF TO cl_salv_table.
*DATA go_event_handler TYPE REF TO lcl_salv_handler.

DATA lt_e071 TYPE TABLE OF e071.

DATA gt_request TYPE TABLE OF ty_s_request.
DATA gs_request_initial TYPE ty_s_request.

DATA gs_e070_start TYPE e070.
DATA go_tra_sim TYPE REF TO lcl_tra_sim.
DATA gt_result2 TYPE TABLE OF ty_gs_result2.
*--------------------------------------------
CLASS lcl_sap_fm IMPLEMENTATION.
  METHOD tr_check_type.
    DATA ls_e071 TYPE e071.
* TR_CHECK_TYPE retourne vide si object = VARX !
* Avec VARI, ï¿½a retourne bien le programme
    ls_e071 = wi_e071.
    IF ls_e071-object = 'VARX'.
      ls_e071-object = 'VARI'.
    ENDIF.
    CALL FUNCTION 'TR_CHECK_TYPE'
      EXPORTING
        wi_e071     = ls_e071
      IMPORTING
        we_tadir    = we_tadir
        we_lock_key = we_lock_key.
  ENDMETHOD.                    "TR_CHECK_TYPE
ENDCLASS.                    "lcl_sap_fm IMPLEMENTATION





*----------------------------------------------------------------------*
INITIALIZATION.
* disable HIGH field for transport request select-options
  TYPE-POOLS sscr.
  DATA: restrict TYPE sscr_restrict,
        opt_list TYPE sscr_opt_list,
        ass TYPE sscr_ass.
  CLEAR opt_list.
  MOVE 'S_TRKORR' TO opt_list-name.
  opt_list-options-eq = 'X'.
  APPEND opt_list TO restrict-opt_list_tab.

  CONCATENATE sy-sysid 'K9' INTO s_trkor2-low.
  APPEND s_trkor2.

  ass-name = 'S_TRKOR2'.
  ass-kind = 'S'.
  ass-sg_main = 'I'.
  ass-sg_addy = space.
  ass-op_main = 'S_TRKORR'.
  APPEND ass TO restrict-ass_tab.

  CALL FUNCTION 'SELECT_OPTIONS_RESTRICT'
    EXPORTING
      restriction = restrict
    EXCEPTIONS
      OTHERS      = 1.

* set default variant to initialize selection screen fields
  IF sy-slset IS INITIAL.
    DATA g_variant TYPE rsvar-variant.
    CONCATENATE 'US' sy-uname INTO g_variant.
    CALL FUNCTION 'RS_SUPPORT_SELECTIONS'
      EXPORTING
        report               = sy-cprog      "actual program name
        variant              = g_variant     "default variant name
      EXCEPTIONS
        variant_not_existent = 1
        variant_obsolete     = 2
        OTHERS               = 3.
    IF sy-subrc = 1.
      CALL FUNCTION 'RS_SUPPORT_SELECTIONS'
        EXPORTING
          report               = sy-cprog                "actual
*program name
          variant              = 'SAPDEFAULT'     "default variant name
        EXCEPTIONS
          variant_not_existent = 0
          variant_obsolete     = 0
          OTHERS               = 0.
    ENDIF.
  ENDIF.


*----------------------------------------------------------------------*
AT SELECTION-SCREEN OUTPUT.
  IF sy-dynnr = 1010.
    CALL METHOD go_tra_sim->display_result.
  ENDIF.


*----------------------------------------------------------------------*
AT SELECTION-SCREEN.
  IF sy-dynnr = 1000 AND sy-ucomm = 'ONLI'.
    CREATE OBJECT go_tra_sim
      EXPORTING
        p_target = p_targe2
        s_trkorr = s_trkor2[]
        p_incstd = p_incst2
        p_srcsys = p_srcsy2
        p_timema = p_timem2.
*  DATA ls_rfcsi TYPE rfcsi.
    DATA l_login_complete TYPE sydebug.
    DATA l_text TYPE c LENGTH 100.
    CALL FUNCTION 'RFC_LOGIN_INFO'
      DESTINATION p_targe2
      IMPORTING
        rfc_login_complete    = l_login_complete
      EXCEPTIONS
        communication_failure = 1  MESSAGE l_text
        system_failure        = 1  MESSAGE l_text.
    IF sy-subrc <> 0 OR l_login_complete <> 'Y'.
      MESSAGE e001(00)
      WITH 'Invalid RFC destination or wrong user/password'(018)
      l_text.
    ENDIF.
  ENDIF.

*----------------------------------------------------------------------*
START-OF-SELECTION.
  go_tra_sim->main2( ).
*  PERFORM main2.
*  PERFORM process1.
*  PERFORM process2.
* Display results (ALV). Note: 1010 is a dummy screen
  CALL SELECTION-SCREEN 1010.
  ASSERT 1 = 1.

*----------------------------------------------------------------------*
CLASS lcl_tra_sim IMPLEMENTATION.
  METHOD constructor.
    me->p_target = p_target.
    me->s_trkorr = s_trkorr.
    me->p_incstd = p_incstd.
    me->p_srcsys = p_srcsys.
    me->p_timema = p_timema.
* Sï¿½lectionner les ordres
*   - et ignorer les entrï¿½es qui sont des tï¿½ches
* TODO: ignore released requests (problï¿½matique ï¿½ traiter car il n'y a
*pas de versioning dans les cross-references)
*          AND trstatus IN ('D','L').  "modifiable
    SELECT * FROM e070 INTO TABLE gt_e070_start
          WHERE trkorr IN s_trkor2
            AND strkorr = space.
    IF lines( s_trkor2 ) <> lines( gt_e070_start ).
      MESSAGE e001(00)
      WITH 'You have entered tasks, replace them with requests'(015).
    ENDIF.
  ENDMETHOD.                    "constructor
  METHOD is_object_custom.
    DATA ls_e071 TYPE e071.
    DATA ls_tadir TYPE tadir.
    DATA l_lines TYPE i.
    DATA l_nameclass TYPE c LENGTH 1.
    DATA l_casting_objname TYPE tadir-obj_name.
    DATA ls_e071_key TYPE type_s_e071_rel.
    DATA ls_tlogoprop  TYPE rstlogoprop.
    DATA l_tlogo  TYPE rs_tlogo.
    DATA lo_type_manager TYPE REF TO cl_rsobjs_type_manager.
    DATA lo_cx_root TYPE REF TO cx_root.
          DATA ls_trnspace TYPE trnspace.

        lo_type_manager = cl_rsobjs_type_manager=>get_instance( ).
        l_tlogo = i_object.
        CLEAR lo_cx_root.
        TRY.
            ls_tlogoprop = lo_type_manager->get_tlogo_type( i_tlogo =
l_tlogo ).
          CATCH cx_rs_not_found INTO lo_cx_root.
        ENDTRY.
        IF lo_cx_root IS NOT BOUND.
* No error -> it's a BI object
          CALL FUNCTION 'RSD_NAME_CHECK'
            EXPORTING
              i_objnm      = i_obj_name
              i_tlogo      = l_tlogo
            EXCEPTIONS
              name_invalid = 1
              OTHERS       = 2.
          IF sy-subrc = 1.
            l_nameclass = 'S'.
          ELSE.
            l_nameclass = 'C'.
          ENDIF.
        ELSE.
          CALL FUNCTION 'TRINT_OBJECT_NAMESPACE_INFO'
            EXPORTING
              iv_pgmid     = 'R3TR'
              iv_object    = i_object
              iv_objname   = i_obj_name
            IMPORTING
              ev_nameclass = l_nameclass
              ev_trnspace  = ls_trnspace
            EXCEPTIONS
              OTHERS       = 4.
          IF sy-subrc <> 0.
            l_nameclass = 'C'.
          ELSEIF l_nameclass CN 'CS'.
            IF ls_trnspace-sapflag IS INITIAL.
              l_nameclass = 'C'.
            ELSE.
              l_nameclass = 'S'.
            ENDIF.
          ENDIF.
        ENDIF.
    if L_nameclass = 'C'.
      r_result = abap_true.
    else.
      r_result = abap_false.
    endif.
  ENDMETHOD.
  METHOD collect2.
*      USING
*        x             TYPE lcl_dev_cross_ref=>type_s_e071_objkey
"object
*        soft_or_hard  TYPE soft_or_hard
*        mmmm          TYPE flag
*        y             TYPE lcl_dev_cross_ref=>type_s_e071_objkey
"subobject
*        subrequest    TYPE ty_s_request
*        force_custom  TYPE flag.
    DATA ls_e071 TYPE e071.
    DATA ls_tadir TYPE tadir.
    DATA l_lines TYPE i.
    DATA l_nameclass TYPE c LENGTH 1.
    DATA l_casting_objname TYPE tadir-obj_name.
    DATA ls_e071_key TYPE type_s_e071_rel.
    DATA ls_tlogoprop  TYPE rstlogoprop.
    DATA l_tlogo  TYPE rs_tlogo.
    DATA lo_type_manager TYPE REF TO cl_rsobjs_type_manager.
    DATA lo_cx_root TYPE REF TO cx_root.
* collecte dans GT_E071_KEY


* Collect only custom objects except if user asked to analyze standard
*too
* For this test, TRINT_OBJECT_NAMESPACE_INFO function module requires
* R3TR, so first convert LIMU into R3TR (and R3TR remains unchanged) by
* calling TR_CHECK_TYPE function module
    ls_e071-pgmid     = y-pgmid.
    ls_e071-object    = y-object.
    ls_e071-obj_name   = y-obj_name.
    CALL METHOD lcl_sap_fm=>tr_check_type
      EXPORTING
        wi_e071  = ls_e071
      IMPORTING
        we_tadir = ls_tadir.


    IF force_custom = 'X'.
      l_nameclass = 'C'.
    ELSE.
* If target object doesn't exist in target system, then process it
*whatever it
* is custom or standard
      READ TABLE gt_e071_dont_exist_in_target
            WITH KEY
              pgmid     = ls_tadir-pgmid
              object    = ls_tadir-object
              obj_name  = ls_tadir-obj_name
            BINARY SEARCH
            TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        l_nameclass = 'C'.
      ELSE.
*        lo_type_manager = cl_rsobjs_type_manager=>get_instance( ).
*        l_tlogo = ls_tadir-object.
*        CLEAR lo_cx_root.
*        TRY.
*            ls_tlogoprop = lo_type_manager->get_tlogo_type( i_tlogo =
*l_tlogo ).
*          CATCH cx_rs_not_found INTO lo_cx_root.
*        ENDTRY.
*        IF lo_cx_root IS NOT BOUND.
** No error -> it's a BI object
*          CALL FUNCTION 'RSD_NAME_CHECK'
*            EXPORTING
*              i_objnm      = ls_tadir-obj_name
*              i_tlogo      = l_tlogo
*            EXCEPTIONS
*              name_invalid = 1
*              OTHERS       = 2.
*          IF sy-subrc = 1.
*            l_nameclass = 'S'.
*          ELSE.
*            l_nameclass = 'C'.
*          ENDIF.
*        ELSE.
*          DATA ls_trnspace TYPE trnspace.
*          CALL FUNCTION 'TRINT_OBJECT_NAMESPACE_INFO'
*            EXPORTING
*              iv_pgmid     = ls_tadir-pgmid
*              iv_object    = ls_tadir-object
*              iv_objname   = ls_tadir-obj_name
*            IMPORTING
*              ev_nameclass = l_nameclass
*              ev_trnspace  = ls_trnspace
*            EXCEPTIONS
*              OTHERS       = 4.
*          IF sy-subrc <> 0.
*            l_nameclass = 'C'.
*          ELSEIF l_nameclass CN 'CS'.
*            IF ls_trnspace-sapflag IS INITIAL.
*              l_nameclass = 'C'.
*            ELSE.
*              l_nameclass = 'S'.
*            ENDIF.
*          ENDIF.
*        ENDIF.
        IF abap_true = is_object_custom(
              i_object  = ls_tadir-object
              i_obj_name = ls_tadir-obj_name ).
          l_nameclass = 'C'.
        ELSE.
          l_nameclass = 'S'.
        ENDIF.
      ENDIF.
    ENDIF.
* nameclass may have values 'S' (standard) or 'C' (customer)
    IF l_nameclass = 'C' OR x IS INITIAL OR p_incstd = 'X'.
* Object is custom
      READ TABLE gt_e071_key INTO ls_e071_key
            WITH KEY
              object    = x
              subobject = y.
      IF sy-subrc <> 0.
        CLEAR ls_e071_key.
* Object was maybe in a TR, get it along with its sequence
        READ TABLE gt_e071_key INTO ls_e071_key
              WITH KEY
                subobject    = x
                soft_or_hard = space
              TRANSPORTING
                subrequest.
        ls_e071_key-request      = ls_e071_key-subrequest.
        CLEAR ls_e071_key-subrequest.
        ls_e071_key-object       = x.
        ls_e071_key-soft_or_hard = soft_or_hard.
        ls_e071_key-mmmm         = mmmm.
        IF subrequest IS INITIAL.
          READ TABLE gt_e071_key INTO ls_e071_key
                WITH KEY
                  subobject    = y
                  soft_or_hard = space
                TRANSPORTING
                  subrequest.
        ELSE.
          ls_e071_key-subrequest    = subrequest.
        ENDIF.
        ls_e071_key-subobject    = y.
        APPEND ls_e071_key TO gt_e071_key.
      ENDIF.
    ENDIF.
  ENDMETHOD.                                                "collect2
*----------------------------------------------------------------------*

  METHOD main2.
    DATA ls_e071_rel TYPE type_s_e071_rel.
    DATA lt_subobj TYPE lcl_dev_cross_ref=>type_t_e071_key.
    FIELD-SYMBOLS <ls_subobj> TYPE
lcl_dev_cross_ref=>type_s_e071_objkey.
    DATA ls_subobj TYPE lcl_dev_cross_ref=>type_s_e071_objkey.

* Build list of objects that exist in released transport requests
*   of the current system, but that don't exist in target system
* This process is time consuming, so a buffering incremental method
* is used (it's time consuming only first time a target system is
* entered)
    CALL METHOD get_e071_dont_exist_in_target
      IMPORTING
        et_e071 = gt_e071_dont_exist_in_target.

* Build GT_E071_KEY
    CALL METHOD build_list_of_objects.

* Complete GT_E071_KEY with subobjects (R3TR PROG may contain LIMU
*DYNP, etc.)
    LOOP AT gt_e071_key INTO ls_e071_rel.
      TRY.
          REFRESH lt_subobj.
          CALL METHOD lcl_dev_cross_ref=>get_subobj
            EXPORTING
              is_object    = ls_e071_rel-subobject
            IMPORTING
              et_subobject = lt_subobj.
          LOOP AT lt_subobj ASSIGNING <ls_subobj>.
            mac_collect2 ls_e071_rel-subobject '' 'X' <ls_subobj>
ls_e071_rel-subrequest ''.
          ENDLOOP.
        CATCH lcx_dev_cross_ref_fm_call.
      ENDTRY.
*    PERFORM get_subobj
*          USING ls_e071_rel-subobject ls_e071_rel-subrequest
*          CHANGING lt_subobj.
    ENDLOOP.

*
    CALL METHOD process1.

*
    CALL METHOD process2.

  ENDMETHOD.                                                "main2

  METHOD build_list_of_objects.
    DATA ls_e071_key TYPE lcl_dev_cross_ref=>type_s_e071_objkey.
    DATA ls_e071 TYPE e071.
    DATA lt_e070_bis TYPE TABLE OF e070.
    DATA lt_rng_trkorr TYPE RANGE OF e070-trkorr.
    DATA ls_rng_trkorr LIKE LINE OF lt_rng_trkorr.
    DATA ls_empty TYPE lcl_dev_cross_ref=>type_s_e071_objkey.
    DATA l_trkorr TYPE e070-trkorr.
    DATA ls_trkorr LIKE LINE OF s_trkorr.
    DATA ls_request TYPE ty_s_request.
    DATA l_tabix TYPE sytabix.
    DATA ls_e071_prev TYPE e071.
    DATA ls_request_prev TYPE ty_s_request.
    DATA lt_e070 TYPE TABLE OF e070.
    DATA ls_e070 TYPE e070.

    REFRESH lt_rng_trkorr.
    LOOP AT gt_e070_start INTO ls_e070.
      ls_rng_trkorr-sign   = 'I'.
      ls_rng_trkorr-option = 'EQ'.
      ls_rng_trkorr-low    = ls_e070-trkorr.
      APPEND ls_rng_trkorr TO lt_rng_trkorr.
    ENDLOOP.

* Determine and store sequence number of the TR in S_TRKORR -> itab
*GT_REQUEST, field SORT
    SORT gt_e070_start BY trkorr.
    REFRESH gt_request.
    CLEAR ls_request.
    LOOP AT s_trkorr INTO ls_trkorr.
      READ TABLE gt_e070_start WITH KEY trkorr = ls_trkorr-low BINARY
SEARCH INTO ls_e070.
      IF sy-subrc = 0.
        ADD 1 TO ls_request-sort.
        ls_request-e070 = ls_e070.
        APPEND ls_request TO gt_request.
      ENDIF.
    ENDLOOP.

* List of requests and tasks containing objects to analyze
    lt_e070_bis = gt_e070_start.
* Take into account tasks not released yet that belong to entered
* transport requests (tasks: STRKORR <> blank; not released: TRSTATUS
*= 'D' or 'L')
    SELECT * FROM e070 INTO TABLE lt_e070
          WHERE strkorr IN lt_rng_trkorr
            AND trstatus IN ('D','L').  "modifiable
    APPEND LINES OF lt_e070 TO lt_e070_bis.

    LOOP AT lt_e070 INTO ls_e070.
      ls_rng_trkorr-sign   = 'I'.
      ls_rng_trkorr-option = 'EQ'.
      ls_rng_trkorr-low    = ls_e070-trkorr.
      APPEND ls_rng_trkorr TO lt_rng_trkorr.
    ENDLOOP.

* Build list of objects ("initial objects") to transport
    SELECT * FROM e071 INTO TABLE lt_e071
          WHERE trkorr IN lt_rng_trkorr
            AND pgmid NE 'CORR'. "ignore CORR RELE lines, they pollute
*the result


* Remove objects that do not exist in source system, because some SAP
*code
* may react with dump later in this tool (like RS_PROGNAME_CONCATENATE
*with
* non-existing class)

    FIELD-SYMBOLS <ls_e071> TYPE e071.
    LOOP AT lt_e071 ASSIGNING <ls_e071>.
      CASE <ls_e071>-object.
        WHEN 'CLAS'.
          DATA ls_clskey TYPE seoclskey.
          ls_clskey-clsname = <ls_e071>-obj_name.
          CALL FUNCTION 'SEO_CLASS_EXISTENCE_CHECK'
            EXPORTING
              clskey        = ls_clskey
            EXCEPTIONS
              not_specified = 1
              not_existing  = 2
              is_interface  = 3
              no_text       = 4
              inconsistent  = 5
              OTHERS        = 6.
          IF sy-subrc = 2.
            DELETE lt_e071.
          ENDIF.
      ENDCASE.
    ENDLOOP.

* Store initial objects, along with the transport request (not the
*   eventual task) to which they belong.
* If same object appears several times, only take into account first
*occurrence
*   in the S_TRKORR sequence (smallest SORT)
* TODO: here I didn't check when same object has 2 different keys (
*LIMU REPS
*   and R3TR PROG for example)
    SORT lt_e070_bis BY trkorr.
    SORT gt_request BY e070-trkorr.
    SORT lt_e071 BY pgmid object obj_name.

    l_tabix = 0.
    DO.
      IF l_tabix > lines( lt_e071 ).
        EXIT.
      ENDIF.
      ADD 1 TO l_tabix.
      READ TABLE lt_e071 INTO ls_e071 INDEX l_tabix.
      IF sy-subrc = 0.
* Get the transport request number when the object is in a non
*released task
        CLEAR ls_e070.
        READ TABLE lt_e070_bis WITH KEY trkorr = ls_e071-trkorr INTO
ls_e070
              BINARY SEARCH.
        IF ls_e070-strkorr IS NOT INITIAL.
          l_trkorr = ls_e070-strkorr.
        ELSE.
          l_trkorr = ls_e070-trkorr.
        ENDIF.
* Get the first transport request in S_TRKORR in which the object
*appears first
*   (when the object belongs to several transport requests)
        READ TABLE gt_request WITH KEY e070-trkorr = l_trkorr INTO
ls_request
              BINARY SEARCH.
      ENDIF.

      IF l_tabix <= lines( lt_e071 )
            AND ls_e071-pgmid = ls_e071_prev-pgmid
            AND ls_e071-object = ls_e071_prev-object
            AND ls_e071-obj_name = ls_e071_prev-obj_name.
* object appears twice, delete one occurrence
        IF ls_request-sort <= ls_request_prev-sort.
* keep current, delete previous
          SUBTRACT 1 FROM l_tabix.
          DELETE lt_e071 INDEX l_tabix.
        ELSE.
* keep previous, delete current
          DELETE lt_e071 INDEX l_tabix.
* reposition for next iteration
          ls_request = ls_request_prev.
          SUBTRACT 1 FROM l_tabix.
        ENDIF.
      ELSEIF l_tabix <> 1.
* each time a new object is to be processed, or after last object,
* add previous object
        ls_e071_key-pgmid    = ls_e071_prev-pgmid.
        ls_e071_key-object   = ls_e071_prev-object.
        ls_e071_key-obj_name = ls_e071_prev-obj_name.
        mac_collect2 ls_empty '' '' ls_e071_key ls_request_prev ''.
      ENDIF.
* current becomes "previous" for next iteration
      ls_e071_prev = ls_e071.
      ls_request_prev = ls_request.
    ENDDO.
  ENDMETHOD.                    "build_list_of_objects
*----------------------------------------------------------------------*
*FORM get_subobj
*      USING
*        is_subobject   TYPE lcl_dev_cross_ref=>type_s_e071_objkey
*        is_subrequest  TYPE type_s_e071_rel-subrequest
*      CHANGING
*        et_subobj               TYPE type_t_e071_key.
*  DATA lt_t100     TYPE TABLE OF t100.
*  DATA ls_t100     TYPE t100.
*  DATA lt_varid    TYPE TABLE OF varid.
*  DATA ls_varid    TYPE varid.
*  DATA ls_e071_key TYPE lcl_dev_cross_ref=>type_s_e071_objkey.
*  DATA ls_e071     TYPE e071.
*  DATA lt_vrso_source TYPE TABLE OF vrso.
*  DATA ls_vrso        TYPE vrso.
*
*  IF is_subobject-pgmid = 'R3TR'.
*    CASE is_subobject-object.
*      WHEN 'MSAG'.
*        SELECT * FROM t100 INTO TABLE lt_t100 WHERE arbgb =
*is_subobject-obj_name.
*        LOOP AT lt_t100 INTO ls_t100.
*          ls_e071_key-pgmid    = 'LIMU'.
*          ls_e071_key-object   = 'MESS'.
*          CONCATENATE is_subobject-obj_name ls_t100-msgnr INTO
*ls_e071_key-obj_name.
*          mac_collect2 is_subobject '' 'X' ls_e071_key is_subrequest
*''.
*        ENDLOOP.
*
*      WHEN OTHERS.
*
** Call TRINT_RESOLVE_OBJ on each system to check existence of all
*subobjects
** If an object is a frame object (R3TR PROG, R3TR FUGR), consider that
** all its subobjects (LIMU DYNP, LIMU FUNC, etc.) belong to the same
** transport request
*        ls_e071-object = is_subobject-object.
*        ls_e071-obj_name = is_subobject-obj_name.
*        REFRESH lt_vrso_source.
*        CALL FUNCTION 'TRINT_RESOLVE_OBJ'
*          EXPORTING
*            is_e071             = ls_e071
*          TABLES
*            et_vrso             = lt_vrso_source
*          EXCEPTIONS
*            not_versionable     = 1
*            communication_error = 2
*            OTHERS              = 3.
*        LOOP AT lt_vrso_source INTO ls_vrso.
*          ls_e071_key-pgmid    = 'LIMU'.
*          ls_e071_key-object   = ls_vrso-objtype.
*          ls_e071_key-obj_name = ls_vrso-objname.
*          mac_collect2 is_subobject '' 'X' ls_e071_key is_subrequest
*''.
*        ENDLOOP.
*    ENDCASE.
** 2010-11-22
** Line LIMU ADIR R3TRSOTR<name> transports implicitly R3TR SOTR <name>
** object so it must be added
*  ELSEIF is_subobject-pgmid = 'LIMU' AND is_subobject-object = 'ADIR'.
*    ls_e071_key-pgmid    = is_subobject-obj_name+0(4).
*    ls_e071_key-object   = is_subobject-obj_name+4(4).
*    ls_e071_key-obj_name = is_subobject-obj_name+8.
*    mac_collect2 is_subobject '' 'X' ls_e071_key is_subrequest ''.
*  ENDIF.
*
*  CASE is_subobject-object.
*    WHEN 'PROG' OR 'REPS' OR 'REPO'.
** propose automatically system variants
*      SELECT * FROM varid CLIENT SPECIFIED
*            INTO TABLE lt_varid
*            WHERE mandt     = '000'  "system variants are only in
*client 000
*              AND report    = is_subobject-obj_name
*              AND transport = space. "system variant
*      LOOP AT lt_varid INTO ls_varid.
*        ls_e071_key-pgmid    = 'LIMU'.
*        ls_e071_key-object   = 'VARX'.
*        CONCATENATE ls_varid-report ls_varid-variant INTO
*ls_e071_key-obj_name RESPECTING BLANKS.
*        mac_collect2 is_subobject 'S' '' ls_e071_key is_subrequest ''.
*      ENDLOOP.
** BI transformation
*    WHEN 'TRFN'.
** gï¿½nï¿½rer les cas d'emploi du programme gï¿½nï¿½rï¿½ de la transformation
*      DATA ls_rstran TYPE rstran.
** OBJ_NAME could be 034QILJDF4LOEOSUXEYPWMS7K6X9K6JU
*      SELECT SINGLE * FROM rstran INTO ls_rstran
*            WHERE tranid = is_subobject-obj_name
*              AND objvers = 'A'.
*      IF sy-subrc = 0.
** rstran-tranprog could be 3KHXIECTOI8OJA7D9NQTQZIWB
** prog -> GP3KHXIECTOI8OJA7D9NQTQZIWB
*        ls_e071_key-pgmid    = 'R3TR'.
*        ls_e071_key-object   = 'PROG'.
*        CONCATENATE 'GP' ls_rstran-tranprog INTO ls_e071_key-obj_name.
*        mac_collect2 is_subobject '' '' ls_e071_key is_subrequest 'X'.
*      ENDIF.
*  ENDCASE.
*ENDFORM.                    "get_subobj

*----------------------------------------------------------------------*

  METHOD process1.
    DATA ls_e071_key        TYPE type_s_e071_rel.
    DATA lo_exc TYPE REF TO cx_root.
    DATA lt_obj TYPE lcl_dev_cross_ref=>type_t_e071_rel.
    DATA ls_obj TYPE lcl_dev_cross_ref=>type_s_e071_rel.

* look for all required subobjects
    LOOP AT gt_e071_key INTO ls_e071_key
          WHERE mmmm IS INITIAL
            AND
      soft_or_hard IS INITIAL.
      REFRESH lt_obj.
      TRY.
          CALL METHOD lcl_dev_cross_ref=>get_reqobj
            EXPORTING
              is_e071_key = ls_e071_key-subobject
            IMPORTING
              et_e071_key = lt_obj.
        CATCH cx_root INTO lo_exc.
          lo_exc->get_longtext( ).
      ENDTRY.
      LOOP AT lt_obj INTO ls_obj.
        mac_collect2 ls_e071_key-subobject ls_obj-soft_or_hard
              ls_e071_key-mmmm ls_obj-subobject gs_request_initial ''.
      ENDLOOP.
    ENDLOOP.

  ENDMETHOD."

*----------------------------------------------------------------------*

  METHOD process2.
    DATA lt_e071_key        TYPE TABLE OF type_s_e071_rel.
    DATA ls_e071_key        TYPE type_s_e071_rel.
    DATA ls_e071_key_2      TYPE type_s_e071_rel.
    DATA ls_trkorr          LIKE LINE OF s_trkorr.
    DATA ls_request         TYPE ty_s_request.
    DATA objname            TYPE vrsd_old-objname.
    DATA objtype            TYPE vrsd_old-objtype.
    DATA ls_e071            TYPE e071.
    DATA lt_vrso_source     TYPE TABLE OF vrso.
    DATA lt_vrso_target     TYPE TABLE OF vrso.
    DATA ls_vrso            TYPE vrso.
    DATA l_string_object    TYPE string.
    DATA l_string_subobject TYPE string.
    DATA ls_tadir           TYPE tadir.
    DATA objname2           TYPE vrsd-objname.
    DATA objtype2           TYPE vrsd-objtype.
    DATA lt_version_target  TYPE TABLE OF vrsd.
    DATA lt_versno_target   TYPE TABLE OF vrsn.
    DATA ls_version_target  TYPE vrsd.
    DATA l_sprsl            TYPE t100-sprsl.
    DATA lt_docu_tab        TYPE TABLE OF rpy_objtab.
    DATA lt_docu_tech       TYPE TABLE OF tline.
    DATA l_not_found        TYPE flag.
    DATA l_trkorr           TYPE e070-trkorr.
    DATA l_lock             TYPE flag.
    DATA l_srcsystem_in_current TYPE tadir-srcsystem.
    DATA l_srcsystem_in_target TYPE tadir-srcsystem.


    SORT gt_e071_key BY subobject.
    lt_e071_key = gt_e071_key.
    DELETE ADJACENT DUPLICATES FROM lt_e071_key COMPARING subobject.


* loop at all required objects
* (MMMM = 'X' when object is included in another one which is
* transported (expl: when R3TR MSAG is to be transported, all its
* messages (LIMU MESS) also exist with MMMM = 'X')
    LOOP AT lt_e071_key INTO ls_e071_key
          WHERE mmmm IS INITIAL.

* Initialize texts which will be used later
      CONCATENATE ls_e071_key-subobject-pgmid
ls_e071_key-subobject-object
            ls_e071_key-subobject-obj_name INTO l_string_subobject
            SEPARATED BY '-'.
      IF ls_e071_key-subrequest IS NOT INITIAL.
        CONCATENATE l_string_subobject ' (' 'TR:'(001)
              ls_e071_key-subrequest-e070-trkorr ')'
              INTO l_string_subobject.
      ENDIF.

      CONCATENATE ls_e071_key-object-pgmid ls_e071_key-object-object
            ls_e071_key-object-obj_name INTO l_string_object
            SEPARATED BY '-'.
      IF ls_e071_key-request IS NOT INITIAL.
        CONCATENATE l_string_object ' (' 'TR:'(001)
              ls_e071_key-request-e070-trkorr ')'
              INTO l_string_object.
      ENDIF.


      READ TABLE gt_result ASSIGNING <ls_result>
            WITH KEY
              object = ls_e071_key-subobject.
      IF sy-subrc <> 0.
        APPEND INITIAL LINE TO gt_result ASSIGNING <ls_result>.
        <ls_result>-object = ls_e071_key-subobject.
        <ls_result>-trkorr = ls_e071_key-subrequest-e070-trkorr.
      ENDIF.


      CALL METHOD check_exists
        EXPORTING
          ls_e071_key            = ls_e071_key-subobject
*         i_target               = p_target
        IMPORTING
          e_not_found            = l_not_found
          e_lock                 = l_lock
          e_trkorr               = l_trkorr
          e_srcsystem_in_current = l_srcsystem_in_current
          e_srcsystem_in_target  = l_srcsystem_in_target.

      IF ls_e071_key-soft_or_hard IS INITIAL.

        IF l_not_found IS INITIAL
              AND l_srcsystem_in_current <> l_srcsystem_in_target.

          IF p_srcsys IS INITIAL.
            <ls_result>-rc      = gcs_result_rc-err.
            <ls_result>-icon    = icon_red_light.
          ELSE.
            <ls_result>-rc      = gcs_result_rc-warn.
            <ls_result>-icon    = icon_yellow_light.
          ENDIF.
          <ls_result>-message =
          'Object has a different source system' &
                'between the 2 systems (TW103)'(002).

        ELSE.

          <ls_result>-rc      = gcs_result_rc-ok.
          <ls_result>-icon    = icon_green_light.
          IF ls_e071_key-object IS INITIAL.
            CONCATENATE 'OK as object is transported in TR'(003)
                  ls_e071_key-request-e070-trkorr
                  INTO <ls_result>-message
                  SEPARATED BY space.
          ELSE.
* TODO: not sure that this code is okay (wrong condition or wrong text)
            CONCATENATE 'OK as its using object'(004) l_string_object
                  'is transported in one of the TRs'(005)
                  INTO <ls_result>-message
                  SEPARATED BY space.
          ENDIF.

        ENDIF.

      ELSE.

************************
* Processing of required objects
************************

        IF ls_e071_key-subrequest IS NOT INITIAL
              AND ls_e071_key-subrequest-sort =
ls_e071_key-request-sort.
          <ls_result>-rc      = gcs_result_rc-ok.
          <ls_result>-icon    = icon_green_light.
          <ls_result>-message = 'OK as required and using objects are'
                & ' in the same TR'(006).

        ELSEIF ls_e071_key-subrequest IS NOT INITIAL
              AND ls_e071_key-subrequest-sort <
ls_e071_key-request-sort.
          <ls_result>-rc      = gcs_result_rc-ok.
          <ls_result>-icon    = icon_green_light.
          CONCATENATE 'OK as using object is in earlier TR'(007)
                ls_e071_key-subrequest-e070-trkorr
                'before required object'(016)
                INTO <ls_result>-message
                SEPARATED BY space.
        ELSE.

* If subobject is neither in current TR nor in one of previous TR (in
*S_TRKORR),
* make sure that it already exists in target system
* In case the object is "soft" required (missing package for example),
* transport request won't fail, so it's just a warning

          IF l_not_found = 'X'.

            IF ls_e071_key-soft_or_hard = 'S'.
              <ls_result>-rc      = gcs_result_rc-warn.
              <ls_result>-icon    = icon_yellow_light.
              CONCATENATE
               'OK though required object is neither transported,'(017)
         ' nor exists in target system, but it is not mandatory'(008)
                     INTO <ls_result>-message.
            ELSE.
              <ls_result>-rc      = gcs_result_rc-err.
              <ls_result>-icon    = icon_red_light.
              <ls_result>-message =
               'Required object does not exist in' &
                    'target system'(009).
            ENDIF.
* Required subobject is provided in one of the TRs in S_TRKORR, but this
* TR should be transported before
            IF ls_e071_key-subrequest IS NOT INITIAL
                  AND ls_e071_key-subrequest-sort >
ls_e071_key-request-sort.
              <ls_result>-rc      = gcs_result_rc-warn.
              <ls_result>-icon    = icon_yellow_light.
              CONCATENATE <ls_result>-message
              'Required object is in TR '(010)
                    ls_e071_key_2-subrequest-e070-trkorr
                    INTO <ls_result>-message.
            ELSE.
* Propose a transport request containing the required object
* (so that user adds it to the list of transport requests (S_TRKORR)
              IF l_not_found IS INITIAL.
                IF l_lock = 'X'.
                  <ls_result>-rc      = gcs_result_rc-warn.
                  <ls_result>-icon    = icon_yellow_light.
                  CONCATENATE <ls_result>-message
                        'Note: required object is locked in TR'(011)
                        l_trkorr INTO <ls_result>-message
                        SEPARATED BY space.
                ELSE.
                  <ls_result>-rc      = gcs_result_rc-warn.
                  <ls_result>-icon    = icon_yellow_light.
                  CONCATENATE <ls_result>-message
                        'Note: object exists in TR '(012) l_trkorr
                        'for example'(013) INTO <ls_result>-message
                        SEPARATED BY space.
                ENDIF.
              ENDIF.
            ENDIF.

          ELSE.

            <ls_result>-rc      = gcs_result_rc-ok.
            <ls_result>-icon    = icon_green_light.
            <ls_result>-message =
            'OK as required object already exists in '
                  & 'target system'(014).
          ENDIF.
        ENDIF.
      ENDIF.

    ENDLOOP.

    check_missing_fields( ).

  ENDMETHOD."

  METHOD check_missing_fields.
    DATA lo_prog TYPE REF TO cl_abap_compiler.
    DATA lt_types TYPE scr_rtags.
    DATA ls_types TYPE LINE OF scr_rtags.
    DATA lt_result2 TYPE scr_glrefs.
    DATA ls_result2 TYPE scr_glref.
    DATA lt_grades TYPE scr_grades.
    DATA ls_grades TYPE LINE OF scr_grades.
    DATA lt_missing_fields TYPE ty_it_type_of_missing.
    FIELD-SYMBOLS <ls_e071_key> TYPE type_s_e071_rel.
    DATA lo_symbol TYPE REF TO cl_abap_comp_symbol.
    DATA lo_type TYPE REF TO cl_abap_comp_type.
    DATA lo_data TYPE REF TO cl_abap_comp_data.
    DATA lo_data_generic TYPE REF TO cl_abap_comp_data_generic.
    DATA lo_data_table_w_header TYPE REF TO
cl_abap_comp_table_with_head.
    DATA lo_structure_type TYPE REF TO cl_abap_comp_structure_type.
    DATA lo_class TYPE REF TO cl_abap_comp_class.


    lt_missing_fields = get_missing_fields( ).


    SORT lt_missing_fields BY fullname.

    TYPES : BEGIN OF ty_ls_program,
              object    TYPE e071-object,
              obj_name  TYPE e071-obj_name,
            END OF ty_ls_program.
    DATA ls_program TYPE ty_ls_program.
    FIELD-SYMBOLS <ls_program> TYPE ty_ls_program.
    DATA lt_program TYPE TABLE OF ty_ls_program.
    REFRESH lt_program.
    LOOP AT gt_e071_key ASSIGNING <ls_e071_key>
                WHERE ( subobject-pgmid = 'R3TR'
              AND ( subobject-object = 'PROG'
                OR  subobject-object = 'FUGR'
                OR  subobject-object = 'CLAS'
            ) )
*            OR ( subobject-pgmid = 'LIMU'
*              AND ( subobject-object = 'REPS'
*                OR  subobject-object = 'METH'
*            ) )
      .
      ls_program-object = <ls_e071_key>-subobject-object.
      ls_program-obj_name = <ls_e071_key>-subobject-obj_name.
      COLLECT ls_program INTO lt_program.
    ENDLOOP.

    LOOP AT lt_program ASSIGNING <ls_program>.
      DATA l_program TYPE program.
      DATA l_obj_name TYPE tadir-obj_name.
      l_obj_name = <ls_program>-obj_name.
      CALL FUNCTION 'RS_TADIR_TO_PROGNAME'
        EXPORTING
          object   = <ls_program>-object
          obj_name = l_obj_name
        IMPORTING
          progname = l_program.

      CREATE OBJECT lo_prog
        EXPORTING
          p_name = l_program.

      ls_types-sign = 'I'.
      ls_types-option = 'EQ'.
      ls_types-low = cl_abap_compiler=>tag_data.
      APPEND ls_types TO lt_types.
      ls_grades-sign = 'I'.
      ls_grades-option = 'EQ'.
      ls_grades-low = cl_abap_compiler=>grade_direct.
      APPEND ls_grades TO lt_grades.

      lo_prog->get_all_refs(
            EXPORTING
              p_local = abap_true
              p_types = lt_types
              p_grades = lt_grades
            IMPORTING
              p_result = lt_result2 ).

      DATA l_start TYPE string.
      l_start = '*'.
*  CONCATENATE '\' cl_abap_compiler=>tag_program ':' progname '\'
*        cl_abap_compiler=>tag_data '*' INTO l_start.
*  LOOP AT lt_result2 INTO ls_result2 WHERE full_name CP l_start.
*    WRITE / ls_result2-full_name.
*  ENDLOOP.

      LOOP AT lt_result2 INTO ls_result2
            WHERE full_name CP l_start
              AND symbol IS BOUND.

        lo_symbol = ls_result2-symbol.
        CLEAR lo_type.
        CASE ls_result2-tag.
          WHEN cl_abap_compiler=>tag_type. "TY
            lo_type ?= lo_symbol.
            CASE lo_type->type_kind.
              WHEN cl_abap_comp_type=>type_kind_structure.
                lo_structure_type ?= lo_type.
              WHEN cl_abap_comp_type=>type_kind_class.
                lo_class ?= lo_type.
              WHEN cl_abap_comp_type=>type_kind_interface.
                ASSERT 1 = 1.
              WHEN cl_abap_comp_type=>type_kind_table.
                ASSERT 1 = 1.
              WHEN cl_abap_comp_type=>type_kind_reference.
                ASSERT 1 = 1.
              WHEN cl_abap_comp_type=>type_kind_elementary.
                ASSERT 1 = 1.
            ENDCASE.
          WHEN cl_abap_compiler=>tag_data. "DA
            CLEAR lo_data.
            CLEAR lo_data_table_w_header.
            CLEAR lo_data_generic.
            TRY.
                lo_data ?= lo_symbol.
              CATCH cx_sy_move_cast_error.
                TRY.
                    lo_data_table_w_header ?= lo_symbol.
                  CATCH cx_sy_move_cast_error.
                    lo_data_generic ?= lo_symbol.
                ENDTRY.
            ENDTRY.
            IF lo_data IS BOUND.
              IF lo_data->type IS NOT BOUND.
* cas se produisant avec les sous-classes, oï¿½ les DATA,
* CONSTANTS et autres, sont dï¿½finies dans les super-classes
* (sous-classe \TY:CL_GUI_SIMPLE_TREE\DA:EVENTID_SELECTION_CHANGED a
*TYPE not bound,
* mais sa super-classe
*\TY:CL_TREE_CONTROL_BASE\DA:EVENTID_SELECTION_CHANGED a TYPE bound)
              ELSE.
                lo_type = lo_data->type.
              ENDIF.
            ENDIF.
        ENDCASE.
        IF lo_type IS BOUND.
          READ TABLE lt_missing_fields
                WITH KEY fullname = lo_type->full_name
                TRANSPORTING NO FIELDS
                BINARY SEARCH.
          IF sy-subrc = 0.
            APPEND INITIAL LINE TO gt_result ASSIGNING <ls_result>.
            <ls_result>-object-object = <ls_program>-object.
            <ls_result>-object-obj_name = <ls_program>-obj_name.
*            <ls_result>-trkorr = <ls_e071_key>-subrequest-e070-trkorr.
            <ls_result>-rc      = gcs_result_rc-err.
            <ls_result>-icon    = icon_red_light.
            CONCATENATE 'Field ' lo_type->full_name ' does not exist'
INTO <ls_result>-message.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

  ENDMETHOD."
*&---------------------------------------------------------------------*
*&      Form  display_result
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
  METHOD display_result.

    DATA ls_e071_key        TYPE type_s_e071_rel.
    DATA lo_columns TYPE REF TO cl_salv_columns_table.
*  DATA lo_events TYPE REF TO cl_salv_events_table.

    TRY.

        CREATE OBJECT go_splitter_container
          EXPORTING
            parent  = cl_gui_container=>screen0
            rows    = 3
            columns = 1.
        go_container_request    = go_splitter_container->get_container(
 row = 1 column = 1 ).
        go_container_error      = go_splitter_container->get_container(
 row = 2 column = 1 ).
        go_container_requiredby = go_splitter_container->get_container(
 row = 3 column = 1 ).


* Remind the entered sequence of transport requests
        SORT gt_request BY sort.
        CALL METHOD cl_salv_table=>factory
          EXPORTING
            r_container  = go_container_request
          IMPORTING
            r_salv_table = go_alv_request
          CHANGING
            t_table      = gt_request.
        lo_columns = go_alv_request->get_columns( ).
        lo_columns->set_optimize( ).
        go_alv_request->display( ).


* List of errors
        CALL METHOD cl_salv_table=>factory
          EXPORTING
            r_container  = go_container_error
          IMPORTING
            r_salv_table = go_alv_error
          CHANGING
            t_table      = gt_result.

        lo_columns = go_alv_error->get_columns( ).
        lo_columns->set_optimize( ).

*  lo_events = go_alv_error->get_event( ).
*  CREATE OBJECT go_event_handler.
*  SET HANDLER go_event_handler->react_to_double_click FOR lo_events.

*  TRY.
*      CALL METHOD go_alv_error->set_screen_status
*        EXPORTING
*          report        = sy-repid
*          pfstatus      = 'ALV'
*          set_functions = cl_salv_table=>c_functions_all.
*    CATCH cx_root.
*      IF 0 = 1. ENDIF.
*  ENDTRY.

        go_alv_error->display( ).




        DATA ls_result2 TYPE ty_gs_result2.

        REFRESH gt_result2.
        LOOP AT gt_result ASSIGNING <ls_result>.
          CLEAR ls_result2.
          ls_result2-object = <ls_result>-object.
          ls_result2-rc = <ls_result>-rc.
*    WRITE : / <ls_result>-object-pgmid, <ls_result>-object-object,
*<ls_result>-object-obj_name.
*    CASE <ls_result>-rc.
*      WHEN gcs_result_rc-ok.
*        WRITE 'OK' COLOR 5.
*      WHEN gcs_result_rc-warn.
*        WRITE 'OK' COLOR 7.
*      WHEN gcs_result_rc-err.
*        WRITE 'KO' COLOR 6.
*    ENDCASE.
*    WRITE : <ls_result>-message.

          DATA l_appended TYPE flag.
          CLEAR l_appended.
          READ TABLE gt_e071_key INTO ls_e071_key
                WITH KEY
                  subobject = <ls_result>-object
                BINARY SEARCH.
          IF sy-subrc = 0.
            LOOP AT gt_e071_key INTO ls_e071_key
                  FROM sy-tabix
                  WHERE
                    subobject = <ls_result>-object.
              ls_result2-subobject = ls_e071_key-object.
              APPEND ls_result2 TO gt_result2.
              l_appended = 'X'.
*        WRITE : / '      ', ls_e071_key-object-pgmid,
*ls_e071_key-object-object, ls_e071_key-object-obj_name.
            ENDLOOP.
          ENDIF.
          IF l_appended IS INITIAL.
            APPEND ls_result2 TO gt_result2.
          ENDIF.
        ENDLOOP.

*... Create requiredby ALV Instance
        CALL METHOD cl_salv_table=>factory
          EXPORTING
            r_container  = go_container_requiredby
          IMPORTING
            r_salv_table = go_alv_requiredby
          CHANGING
            t_table      = gt_result2.
        lo_columns = go_alv_requiredby->get_columns( ).
        lo_columns->set_optimize( ).

*... Display ALV
        go_alv_requiredby->display( ).

      CATCH cx_salv_msg.
    ENDTRY.

  ENDMETHOD."

*----------------------------------------------------------------------*

  METHOD check_exists.

    DATA ls_e071        TYPE e071.
    DATA objtype2       TYPE vrsd-objtype.
    DATA objtype        TYPE vrsd_old-objtype.
    DATA objname2       TYPE vrsd-objname.
    DATA ls_tadir       TYPE tadir.
    DATA lt_version_target  TYPE TABLE OF vrsd.
    DATA lt_versno_target   TYPE TABLE OF vrsn.
    DATA ls_version_target  TYPE vrsd.
    DATA l_sprsl        TYPE t100-sprsl.
    DATA lt_docu_tab    TYPE TABLE OF rpy_objtab.
    DATA lt_docu_tech   TYPE TABLE OF tline.
    DATA ls_lock_key   TYPE tlock_int.
    DATA lt_tlock      TYPE TABLE OF tlock.
    DATA ls_tlock      TYPE tlock.
    TYPES : BEGIN OF type_s_trkorr,
              as4date TYPE e070-as4date,
              as4time TYPE e070-as4time,
              trkorr  TYPE e070-trkorr,
            END OF type_s_trkorr.
    DATA lt_trkorr     TYPE TABLE OF type_s_trkorr.
    DATA ls_trkorr     TYPE type_s_trkorr.
    DATA l_timestamp   TYPE tzntimestp.
    DATA l_timestamp2  TYPE tzntimestp.

    CLEAR objtype2.
    CLEAR e_not_found.
    CLEAR e_lock.
    CLEAR e_trkorr.
    CLEAR e_srcsystem_in_target.
    CLEAR e_srcsystem_in_current.

    ls_e071-pgmid    = ls_e071_key-pgmid.
    ls_e071-object   = ls_e071_key-object.
    ls_e071-obj_name = ls_e071_key-obj_name.

    CALL METHOD lcl_sap_fm=>tr_check_type
      EXPORTING
        wi_e071     = ls_e071
      IMPORTING
        we_tadir    = ls_tadir
        we_lock_key = ls_lock_key.


    IF p_timema IS NOT INITIAL.
* rechercher les OT qui contiennent l'objet, et prendre
* la date et heure de l'OT le + ancien, ce qui donne
* l'heure de crï¿½ation de l'OT donc de l'objet.
      CALL METHOD get_creation_timestamp
        EXPORTING
          i_pgmid     = ls_tadir-pgmid
          i_object    = ls_tadir-object
          i_obj_name  = ls_tadir-obj_name
        IMPORTING
          e_timestamp = l_timestamp.
* Si l'on a transportï¿½ un REPS sans que PROG soit transportï¿½, cela
* crï¿½e tout de mï¿½me une entrï¿½e PROG
      IF ls_e071-object = 'REPS' OR ls_e071-object = 'REPO'.
        CALL METHOD get_creation_timestamp
          EXPORTING
            i_pgmid     = ls_e071-pgmid
            i_object    = ls_e071-object
            i_obj_name  = ls_e071-obj_name
          IMPORTING
            e_timestamp = l_timestamp2.
        IF l_timestamp2 IS NOT INITIAL AND l_timestamp2 < l_timestamp.
          l_timestamp = l_timestamp2.
        ENDIF.
      ENDIF.
    ENDIF.

* Si l'objet a ï¿½tï¿½ crï¿½ï¿½ aprï¿½s la date/heure choisis, considï¿½rer
* qu'il n'existe pas
    IF p_timema IS NOT INITIAL AND l_timestamp >= p_timema.
      e_not_found = 'X'.
    ELSE.

      CASE ls_e071_key-pgmid.
        WHEN 'LIMU'.
          CASE ls_e071_key-object.
            WHEN 'CINC' OR 'CLSD' OR 'CPRI' OR 'CPRO' OR 'CPUB' OR
'CUAD'
                  OR 'DOMD' OR 'DTED' OR 'DYNP' OR 'ENQD' OR 'FUNC' OR
'INDX'
                  OR 'METH' OR 'SHLD' OR 'SHLX' OR 'SQLD' OR 'TABD' OR
'TABT'
                  OR 'TTYD' OR 'TYPD' OR 'VIED' OR 'VIET' OR 'WAPD' OR
'WDYC'
                  OR 'WDYD' OR 'WDYV'
                  OR 'REPO' OR 'REPS' OR 'REPT'.
* Pour REPO, REPS, REPT, faut-il tester PROG ou FUGR ou CLAS ou autre
*chose?
* RS_PROGNAME_SPLIT -> si fugr_is_name = 'X' alors chercher existence
*de TADIR FUGR?
              objtype = ls_e071_key-object.
              objname2 = ls_e071_key-obj_name.
              REFRESH lt_version_target.
              CALL FUNCTION 'SVRS_GET_VERSION_DIRECTORY_46'
                DESTINATION p_target
                EXPORTING
                  objname      = objname2
                  objtype      = objtype
                TABLES
                  lversno_list = lt_versno_target
                  version_list = lt_version_target
                EXCEPTIONS
                  no_entry     = 1
                  OTHERS       = 2.
              IF sy-subrc <> 0.
                e_not_found = 'X'.
              ELSE.
                READ TABLE lt_version_target INTO ls_version_target
                      WITH KEY loekz = 'I'.
                e_trkorr = ls_version_target-korrnum.
              ENDIF.
            WHEN 'INTD'.
              objtype = 'INTF'.
              objname2 = ls_e071_key-obj_name.
              REFRESH lt_version_target.
              CALL FUNCTION 'SVRS_GET_VERSION_DIRECTORY_46'
                DESTINATION p_target
                EXPORTING
                  objname      = objname2
                  objtype      = objtype
                TABLES
                  lversno_list = lt_versno_target
                  version_list = lt_version_target
                EXCEPTIONS
                  no_entry     = 1
                  OTHERS       = 2.
              IF sy-subrc <> 0.
                e_not_found = 'X'.
              ELSE.
                READ TABLE lt_version_target INTO ls_version_target
                      WITH KEY loekz = 'I'.
                e_trkorr = ls_version_target-korrnum.
              ENDIF.
            WHEN 'DEVP'.
              objtype2 = 'DEVC'.
            WHEN 'DOCU'.
              IF ls_e071_key-obj_name(2) = 'TX'.
                objtype2 = 'DOCT'.
              ELSE.
                objtype2 = 'DOCV'.
              ENDIF.
            WHEN 'FUGT'.
              objtype2 = 'FUGR'.
            WHEN 'MESS'.
*VRSD-OBJTYPE
*VRSD-OBJNAME
              DATA l_objname_long TYPE vrsd-objname.
              objtype2 = ls_e071_key-object.
              objname2 = ls_e071_key-obj_name.
              CALL FUNCTION 'SVRS_SHORT2LONG_NAME'
                EXPORTING
                  objtype       = objtype2
                  objname_short = objname2
                IMPORTING
                  objname_long  = l_objname_long.
              SELECT SINGLE sprsl FROM t100 INTO l_sprsl
                    WHERE arbgb = l_objname_long(20)
                      AND msgnr = l_objname_long+20(3).
              DATA l_casting_msgno TYPE symsgno.
              l_casting_msgno = l_objname_long+20(3).
              CALL FUNCTION 'RPY_MESSAGE_COMPOSE'
                DESTINATION p_target
                EXPORTING
                  language          = l_sprsl
                  message_id        = l_objname_long(20)
                  message_number    = l_casting_msgno
                EXCEPTIONS
                  message_not_found = 1
                  OTHERS            = 2.
              IF sy-subrc <> 0.
                e_not_found = 'X'.
              ENDIF.
              CLEAR objtype2.
            WHEN 'MSAD'.
              objtype2 = 'MSAG'.
            WHEN 'SOTT' OR 'SOTU'.
              objtype2 = 'MSAG'.
            WHEN 'SQTT'.
              objtype2 = 'SQLS'.
            WHEN 'TTYX'.
              objtype2 = 'TTYP'.
            WHEN 'VARI' OR 'VARX'.
              objtype2 = 'PROG'.
            WHEN 'WAPP'.
              objtype2 = 'WAPA'.  "??
            WHEN 'ADIR' OR 'COMM' OR 'FSEL' OR 'MAPP' OR 'MCOD' OR
'PIFA' OR 'PIFH' OR 'XIND'.
* Objets LIMU non gï¿½rï¿½s
          ENDCASE.

        WHEN 'R3TR'.
          objtype2 = ls_e071_key-object.
      ENDCASE.


      DATA l_object_casting TYPE e071-object.
      DATA l_objname_casting TYPE e071-obj_name.
      l_object_casting = ls_tadir-object.
      l_objname_casting = ls_tadir-obj_name.
      CALL FUNCTION 'SRTT_GET_REMOTE_TADIR_ENTRY'
        EXPORTING
          tadir_object  = l_object_casting
          tadir_objname = l_objname_casting
        IMPORTING
          et_tadir      = ls_tadir
        EXCEPTIONS
          invalid       = 1
          OTHERS        = 2.
      e_srcsystem_in_current = ls_tadir-srcsystem.

      CALL FUNCTION 'SRTT_GET_REMOTE_TADIR_ENTRY'
        DESTINATION p_target
        EXPORTING
          tadir_object  = l_object_casting
          tadir_objname = l_objname_casting
        IMPORTING
          et_tadir      = ls_tadir
        EXCEPTIONS
          invalid       = 1
          OTHERS        = 2.
      IF sy-subrc <> 0 AND objtype2 IS NOT INITIAL.
        e_not_found = 'X'.
      ENDIF.
      e_srcsystem_in_target = ls_tadir-srcsystem.

    ENDIF.


* rechercher l'OT dans le systï¿½me courant oï¿½ se trouve l'objet
*********************************
* retourne la tï¿½che ou l'OT dans lequel l'objet est verrouillï¿½
    CALL FUNCTION 'TRINT_CHECK_LOCKS'
      EXPORTING
        wi_lock_key = ls_lock_key
      TABLES
        wt_tlock    = lt_tlock
      EXCEPTIONS
        empty_key   = 1
        OTHERS      = 2.
    IF sy-subrc = 0 AND lt_tlock[] IS NOT INITIAL.
      READ TABLE lt_tlock INTO ls_tlock INDEX 1.
      IF sy-subrc = 0.
        e_trkorr = ls_tlock-trkorr.
        e_lock = 'X'.
* chercher l'OT si le retour est une tï¿½che
        SELECT SINGLE strkorr FROM e070 INTO e_trkorr WHERE trkorr =
e_trkorr.
      ENDIF.
    ELSE.

* Si l'objet n'est pas verrouillï¿½, rechercher l'ordre de transport
* libï¿½rï¿½ en dernier
      SELECT e070~as4date e070~as4time e070~trkorr
            FROM e071
              INNER JOIN e070
                ON e071~trkorr = e070~trkorr
            INTO TABLE lt_trkorr
            WHERE e071~pgmid    = ls_e071_key-pgmid
              AND e071~object   = ls_e071_key-object
              AND e071~obj_name = ls_e071_key-obj_name
            ORDER BY
              e070~as4date DESCENDING
              e070~as4time DESCENDING
            %_HINTS ORACLE 'FIRST_ROWS(1)'.
      READ TABLE lt_trkorr INTO ls_trkorr INDEX 1.
      e_trkorr = ls_trkorr-trkorr.
    ENDIF.

  ENDMETHOD."

*&---------------------------------------------------------------------*
*&      Form  TABLSTRUC_FIELD
*&---------------------------------------------------------------------*
  METHOD tablstruc_field.
*   USING is_dd03p TYPE dd03p is_e071_key TYPE
*lcl_dev_cross_ref=>type_s_e071_objkey.
    DATA ls_e071_key TYPE lcl_dev_cross_ref=>type_s_e071_objkey.
* .APPEND_DU indique une rï¿½cursivitï¿½, PRECFIELD est blanc. A ignorer.
    IF is_dd03p-fieldname = '.APPEND_DU'.
* .INCLU-*** indique un include avec suffixe *** pour les composantes
    ELSEIF is_dd03p-fieldname = '.APPEND'
          OR is_dd03p-fieldname(6) = '.INCLU'.
      ls_e071_key-pgmid    = 'R3TR'.
      ls_e071_key-object   = 'TABL'.
      ls_e071_key-obj_name = is_dd03p-precfield.
      mac_collect2 is_e071_key 'H' '' ls_e071_key gs_request_initial ''.
* composantes avec type interne/longueur ont COMPTYPE = blanc
* (bizarrement, parfois, ROLLNAME n'est pas ï¿½ blanc!)
    ELSEIF NOT is_dd03p-comptype IS INITIAL.
      ls_e071_key-pgmid    = 'R3TR'.
      DATA l_link TYPE c LENGTH 1.
      l_link = 'H'.
      CASE is_dd03p-comptype.
        WHEN 'E'.
          ls_e071_key-object   = 'DTEL'.
        WHEN 'S'.
          ls_e071_key-object   = 'TABL'.
        WHEN 'L'.
          ls_e071_key-object   = 'TTYP'.
        WHEN 'R'. "type ref to
          CASE is_dd03p-reftype.
            WHEN 'C'.
              ls_e071_key-object   = 'CLAS'.
            WHEN 'I'.
              ls_e071_key-object   = 'INTF'.
            WHEN 'E'.
              ls_e071_key-object   = 'DTEL'.
            WHEN 'S'. "structure or table
              ls_e071_key-object   = 'TABL'.
            WHEN 'L'.
              ls_e071_key-object   = 'TTYP'.
            WHEN space. "undefined
              DATA l_typename TYPE typename.
              DATA l_typekind TYPE ddtypekind.
              l_typename = is_dd03p-rollname.
              CALL FUNCTION 'DDIF_TYPEINFO_GET'
                EXPORTING
                  typename = l_typename
                IMPORTING
                  typekind = l_typekind.
              IF l_typekind IS NOT INITIAL.
                ls_e071_key-object   = l_typekind.
              ENDIF.
            WHEN 'B'.
* reference to an internal data type, length, decimals -> IGNORE
            WHEN OTHERS.
              ASSERT is_dd03p-reftype = 'D' "data
                    OR is_dd03p-reftype = 'O'. "object
          ENDCASE.
        WHEN 'N'. "structure inexistante (ou inactive) CI_*
          ls_e071_key-object   = 'TABL'.
          l_link = 'S'. "l'include ci_* peut ne pas exister
        WHEN OTHERS.
          MESSAGE x001(00).
      ENDCASE.
      IF ls_e071_key-object IS NOT INITIAL.
        ls_e071_key-obj_name = is_dd03p-rollname.
        mac_collect2 is_e071_key l_link '' ls_e071_key
gs_request_initial ''.
      ENDIF.
    ENDIF.
  ENDMETHOD.                    "tablstruc_field

*&---------------------------------------------------------------------*
*&      Form  GET_TABLE_TYPE
*&---------------------------------------------------------------------*
  METHOD get_table_type.
*      USING
*        i_tabname
*      CHANGING
*        e_object.
    DATA l_typename TYPE typename.
    DATA l_gotstate TYPE ddgotstate.
    DATA l_typekind TYPE ddtypekind.

    CLEAR e_object.

    l_typename = i_tabname.
    CALL FUNCTION 'DDIF_TYPEINFO_GET'
      EXPORTING
        typename = l_typename
      IMPORTING
        typekind = l_typekind
        gotstate = l_gotstate.
    e_object = l_typekind.

  ENDMETHOD.                    "get_table_type

*&---------------------------------------------------------------------*
*&      Form  CONVERT_WBOBJ_KEY_INTO_E071
*&---------------------------------------------------------------------*
  METHOD convert_wbobj_key_into_e071.
*      USING
*        is_wbobj_key    TYPE  type_s_wbobj_key
*      CHANGING
*        es_e071_key     TYPE  lcl_dev_cross_ref=>type_s_e071_objkey.

    DATA ls_ko100 TYPE ko100.

* dï¿½termine si le type (PROG, CLAS, DYNP, etc.) correspond ï¿½ R3TR ou ï¿½
*LIMU
    CALL FUNCTION 'TR_GET_PGMID_FOR_OBJECT'
      EXPORTING
        iv_object      = is_wbobj_key-object
      IMPORTING
        es_type        = ls_ko100
      EXCEPTIONS
        illegal_object = 1
        OTHERS         = 2.

    CLEAR es_e071_key.
    es_e071_key-pgmid    = ls_ko100-pgmid.
    es_e071_key-object = is_wbobj_key-object.

    CASE is_wbobj_key-object.

* First we take care for objects that are unknown to RS_TOOL_ACCESS
      WHEN 'DOCU'.
        es_e071_key-obj_name(2) = is_wbobj_key-s_docu-docu_id.
        es_e071_key-obj_name+2 = is_wbobj_key-s_docu-docu_object.


      WHEN 'SOTT' OR 'SOTU'.
        es_e071_key-obj_name(30) = is_wbobj_key-s_sott-paket.
        es_e071_key-obj_name+30 = is_wbobj_key-s_sott-concept.


      WHEN 'TOBJ'.
        CONCATENATE is_wbobj_key-s_tobj-objectname
                    is_wbobj_key-s_tobj-objecttype
            INTO es_e071_key-obj_name.


      WHEN 'MERG' OR 'RELE' OR 'COMM'.
        es_e071_key-obj_name = is_wbobj_key-trkorr.


      WHEN 'SPCS'.
        es_e071_key-obj_name = is_wbobj_key-s_spcs-codepage.
      WHEN 'SPSV'.
        es_e071_key-obj_name = is_wbobj_key-s_spsv-server.
      WHEN 'SPDV'.
        SELECT SINGLE name FROM tsp03d INTO es_e071_key-obj_name
              WHERE padest = is_wbobj_key-s_spdv-device.
      WHEN 'SPLO'.
        es_e071_key-obj_name = is_wbobj_key-s_splo-paper_format.
      WHEN 'PRIN'.
        es_e071_key-obj_name = is_wbobj_key-s_prin-printer_type.
      WHEN 'SLOM'.
        es_e071_key-obj_name =
is_wbobj_key-s_slom-logical_output_system.
      WHEN 'SOMS'.
        es_e071_key-obj_name = is_wbobj_key-s_soms-read_output_system.


      WHEN 'SCP1'.
        es_e071_key-obj_name = is_wbobj_key-s_scp-bcset_id.
      WHEN 'SCP2'.
        es_e071_key-obj_name = is_wbobj_key-s_scp-bcset_id.


      WHEN 'FILE'.
        es_e071_key-obj_name = is_wbobj_key-file.

      WHEN 'REPO'.
        es_e071_key-obj_name = is_wbobj_key-include.

      WHEN 'DYNP'.
        es_e071_key-pgmid    = 'LIMU'.
        es_e071_key-obj_name+gc_prog(gc_dynp) =
is_wbobj_key-s_dynp-screen_number.
        es_e071_key-obj_name(gc_prog)         =
is_wbobj_key-s_dynp-program_name.

      WHEN 'VARI' OR 'VARX'.
        es_e071_key-obj_name+gc_prog(gc_vari) =
is_wbobj_key-s_vari-variant_name.
        es_e071_key-obj_name(gc_prog)         =
is_wbobj_key-s_vari-program_name.

      WHEN 'MESS'.
        es_e071_key-pgmid    = 'LIMU'.
        CONCATENATE is_wbobj_key-s_mess-msg_class_name
                    is_wbobj_key-s_mess-msg_number
              INTO es_e071_key-obj_name.

      WHEN 'METH'.
        es_e071_key-pgmid    = 'LIMU'.
        es_e071_key-obj_name+gc_clas(gc_meth) =
is_wbobj_key-s_meth-method_name.
        es_e071_key-obj_name(gc_clas)         =
is_wbobj_key-s_meth-class_name.

* Web Dynpro controller
      WHEN 'WDYC'.
        es_e071_key-obj_name+gc_wdyn(gc_wdyc) =
is_wbobj_key-s_wdyc-controller_name.
        es_e071_key-obj_name(gc_wdyn) =
is_wbobj_key-s_wdyc-webdynpro_name.

* Web Dynpro view
      WHEN 'WDYV'.
        es_e071_key-obj_name+gc_wdyn(gc_wdyv) =
is_wbobj_key-s_wdyv-view_name.
        es_e071_key-obj_name(gc_wdyn) =
is_wbobj_key-s_wdyv-webdynpro_name.

* Page/Controller of a BSP Application
      WHEN 'WAPD' OR 'WAPP'.
        es_e071_key-obj_name+gc_wapa(gc_wapp) =
is_wbobj_key-s_wapp-page_name.
        es_e071_key-obj_name(gc_wapa) = is_wbobj_key-s_wapp-appl_name.

      WHEN OTHERS.
        es_e071_key-obj_name = is_wbobj_key-object.

    ENDCASE.
  ENDMETHOD.                    "convert_wbobj_key_into_e071

*&---------------------------------------------------------------------*
*&      Method  GET_MISSING_FIELDS
*&---------------------------------------------------------------------*
  METHOD get_missing_fields.

    DATA l_table    TYPE dd02l-tabname.
    DATA lt_option  TYPE TABLE OF rfc_db_opt.
    DATA lt_field   TYPE TABLE OF rfc_db_fld.
    DATA lte_data   TYPE TABLE OF tab512.
    DATA ls_option  TYPE rfc_db_opt.
    DATA ls_field   TYPE rfc_db_fld.
    DATA l_data     TYPE tab512.
    DATA l_trkorr   TYPE e070-trkorr.
    DATA l_dummy_dd03l TYPE dd03l.
*    FIELD-SYMBOLS <ls_dd03l> TYPE dd03l.
    TYPES : BEGIN OF ty_ls_dd03l,
              tabname     TYPE dd03l-tabname,
              fieldname   TYPE dd03l-fieldname,
              position    TYPE dd03l-position,
              comptype    TYPE dd03l-comptype,
              rollname    TYPE dd03l-rollname,
              datatype    TYPE dd03l-datatype,
              leng        TYPE dd03l-leng,
            END OF ty_ls_dd03l.
    DATA lt_dd03l_source TYPE TABLE OF ty_ls_dd03l.
    DATA lt_dd03l_target TYPE TABLE OF ty_ls_dd03l.
    DATA lt_dd03l_target2 TYPE TABLE OF ty_ls_dd03l.
    FIELD-SYMBOLS <ls_e071_key> TYPE type_s_e071_rel.
    FIELD-SYMBOLS <ls_dd03l> TYPE ty_ls_dd03l.
    DATA lt_obj_name TYPE TABLE OF type_s_e071_rel-subobject-obj_name.
    DATA lt_obj_name2 TYPE TABLE OF type_s_e071_rel-subobject-obj_name.
    FIELD-SYMBOLS <l_obj_name> TYPE type_s_e071_rel-subobject-obj_name.

    REFRESH lt_obj_name.
    LOOP AT gt_e071_key ASSIGNING <ls_e071_key>
          WHERE ( subobject-pgmid = 'R3TR'
              AND ( subobject-object = 'TABL'
*                OR  object = 'TABD'
            ) )
            OR ( subobject-pgmid = 'LIMU'
              AND ( subobject-object = 'TABD'
*                OR  object = ''
            ) ).
      COLLECT <ls_e071_key>-subobject-obj_name INTO lt_obj_name.
    ENDLOOP.

    REFRESH lt_obj_name2.

    WHILE lt_obj_name IS NOT INITIAL.

      APPEND LINES OF lt_obj_name TO lt_obj_name2.

      REFRESH lt_option.
      LOOP AT lt_obj_name ASSIGNING <l_obj_name>.
        IF sy-tabix = 1.
          CONCATENATE 'TABNAME = ''' <l_obj_name> '''' INTO
ls_option-text.
          APPEND ls_option TO lt_option.
        ELSE.
          CONCATENATE 'OR TABNAME = ''' <l_obj_name> '''' INTO
ls_option-text.
          APPEND ls_option TO lt_option.
        ENDIF.
      ENDLOOP.

      REFRESH lt_field.
      ls_field-fieldname = 'TABNAME'.
      APPEND ls_field TO lt_field.
      ls_field-fieldname = 'FIELDNAME'.
      APPEND ls_field TO lt_field.
      ls_field-fieldname = 'POSITION'.
      APPEND ls_field TO lt_field.
      ls_field-fieldname = 'COMPTYPE'.
      APPEND ls_field TO lt_field.
      ls_field-fieldname = 'ROLLNAME'.
      APPEND ls_field TO lt_field.
      ls_field-fieldname = 'DATATYPE'.
      APPEND ls_field TO lt_field.
      ls_field-fieldname = 'LENG'.
      APPEND ls_field TO lt_field.

      l_table = 'DD03L'.
      CALL FUNCTION 'RFC_READ_TABLE'
        DESTINATION p_target
        EXPORTING
          query_table          = l_table
        TABLES
          options              = lt_option
          fields               = lt_field
          data                 = lte_data
        EXCEPTIONS
          table_not_available  = 1
          table_without_data   = 2
          option_not_valid     = 3
          field_not_valid      = 4
          not_authorized       = 5
          data_buffer_exceeded = 6
          OTHERS               = 7.
      IF sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      ENDIF.

      lt_dd03l_target2 = lte_data.
      APPEND LINES OF lt_dd03l_target2 TO lt_dd03l_target.

      REFRESH lt_obj_name.
*      LOOP AT lt_dd03l_target ASSIGNING <ls_dd03l> WHERE comptype =
*'S'.
*        READ TABLE lt_obj_name2 WITH KEY table_line =
*<ls_dd03l>-rollname TRANSPORTING NO FIELDS.
*        IF sy-subrc <> 0.
*          APPEND <ls_dd03l>-rollname TO lt_obj_name.
*        ENDIF.
*      ENDLOOP.

    ENDWHILE.

    SORT lt_dd03l_target BY tabname position.

*-----------------------
* Read fields of structures and tables in source system
*-----------------------
*data lt_rng_tabname type range of dd03l-tabname.
*field-symbols <ls_rng_tabname> like line of lt_rng_tabname.
*refresh lt_rng_tabname.
*loop at lt_obj_name2 assigning <l_obj_name>.
*  append initial line to lt_rng_tabname assigning <ls_rng_tabname>.
*<ls_rng_tabname>-sign   = 'I'.
*<ls_rng_tabname>-option = 'EQ'.
*<ls_rng_tabname>-low    = <l_obj_name>.
*endloop.
    REFRESH lt_dd03l_source.
    IF lt_obj_name2 IS NOT INITIAL.
      SELECT tabname fieldname position comptype rollname datatype leng
            FROM dd03l
            INTO TABLE lt_dd03l_source
            FOR ALL ENTRIES IN lt_obj_name2
            WHERE tabname = lt_obj_name2-table_line(30).
    ENDIF.

*-----------------------
* Determine missing fields
*-----------------------
    TYPES : BEGIN OF ty_ls_missing_field,
              tabname   TYPE dd03l-tabname,
              fieldname  TYPE dd03l-fieldname,
            END OF ty_ls_missing_field.
    DATA lt_missing_field TYPE TABLE OF ty_ls_missing_field.
    FIELD-SYMBOLS <ls_missing_field> TYPE ty_ls_missing_field.

    REFRESH lt_missing_field.
    LOOP AT lt_dd03l_source ASSIGNING <ls_dd03l>.
      READ TABLE lt_dd03l_target
            WITH KEY
              tabname = <ls_dd03l>-tabname
              fieldname = <ls_dd03l>-fieldname
            TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.
        APPEND INITIAL LINE TO lt_missing_field ASSIGNING
<ls_missing_field>.
        <ls_missing_field>-tabname = <ls_dd03l>-tabname.
        <ls_missing_field>-fieldname = <ls_dd03l>-fieldname.
      ENDIF.
    ENDLOOP.

*-----------------------
* Build full name of missing fields
*-----------------------
*    DATA lt_type_of_missing TYPE ty_it_type_of_missing.
    FIELD-SYMBOLS <ls_type_of_missing> TYPE ty_is_type_of_missing.
    FIELD-SYMBOLS <ls_type_of_missing2> TYPE ty_is_type_of_missing.

    REFRESH rt_result.
    LOOP AT lt_missing_field ASSIGNING <ls_missing_field>.
      APPEND INITIAL LINE TO rt_result ASSIGNING <ls_type_of_missing>.
      <ls_type_of_missing>-tabname = <ls_missing_field>-tabname.
      CONCATENATE '\TY:' <ls_missing_field>-tabname '\TY:'
<ls_missing_field>-fieldname INTO <ls_type_of_missing>-fullname.
    ENDLOOP.

    LOOP AT rt_result ASSIGNING <ls_type_of_missing>.
      LOOP AT lt_dd03l_source ASSIGNING <ls_dd03l>
            WHERE comptype = 'S'
              AND rollname = <ls_type_of_missing>-tabname.
        APPEND <ls_type_of_missing> TO rt_result ASSIGNING
<ls_type_of_missing2>.
        <ls_type_of_missing2>-tabname = <ls_dd03l>-tabname.
        CONCATENATE '\TY:' <ls_dd03l>-tabname
<ls_type_of_missing>-fullname INTO <ls_type_of_missing2>-fullname.
      ENDLOOP.
    ENDLOOP.

  ENDMETHOD."

*&---------------------------------------------------------------------*
*&      Method  GET_CREATION_TIMESTAMP
*&---------------------------------------------------------------------*
* Rechercher la date et l'heure de crï¿½ation d'un objet
* en se basant sur la date du premier ordre de transport qui
* le contient
  METHOD get_creation_timestamp.
*      USING
*        i_pgmid     TYPE e071-pgmid
*        i_object    TYPE e071-object
*        i_obj_name  TYPE clike
*      CHANGING
*        e_timestamp TYPE tzntimestp.

    DATA l_table TYPE dd02l-tabname.
    DATA lt_option TYPE TABLE OF rfc_db_opt.
    DATA lt_field TYPE TABLE OF rfc_db_fld.
    DATA lte_data TYPE TABLE OF tab512.
    DATA ls_option TYPE rfc_db_opt.
    DATA ls_field TYPE rfc_db_fld.
    DATA l_data TYPE tab512.
    DATA l_trkorr TYPE e070-trkorr.

    CONCATENATE 'PGMID = ''' i_pgmid '''' INTO ls_option-text.
    APPEND ls_option TO lt_option.
    CONCATENATE 'AND OBJECT = ''' i_object '''' INTO ls_option-text.
    APPEND ls_option TO lt_option.
    CONCATENATE 'AND OBJ_NAME = ''' i_obj_name '''' INTO ls_option-text.
    APPEND ls_option TO lt_option.
    ls_field-fieldname = 'TRKORR'.
    APPEND ls_field TO lt_field.

    l_table = 'E071'.
    CALL FUNCTION 'RFC_READ_TABLE'
      DESTINATION p_target
      EXPORTING
        query_table          = l_table
      TABLES
        options              = lt_option
        fields               = lt_field
        data                 = lte_data
      EXCEPTIONS
        table_not_available  = 1
        table_without_data   = 2
        option_not_valid     = 3
        field_not_valid      = 4
        not_authorized       = 5
        data_buffer_exceeded = 6
        OTHERS               = 7.
    IF sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.

    REFRESH lt_option.
    LOOP AT lte_data INTO l_data.
      IF lt_option[] IS INITIAL.
        CONCATENATE 'TRKORR = ''' l_data '''' INTO ls_option-text.
      ELSE.
        CONCATENATE 'OR TRKORR = ''' l_data '''' INTO ls_option-text.
      ENDIF.
      APPEND ls_option TO lt_option.
    ENDLOOP.
    REFRESH lt_field.
    ls_field-fieldname = 'AS4DATE'.
    APPEND ls_field TO lt_field.
    ls_field-fieldname = 'AS4TIME'.
    APPEND ls_field TO lt_field.
    REFRESH lte_data.
    l_table = 'E070'.
* A noter qu'on ne peut utiliser la table E070CREATE qui n'est pas
* alimentï¿½e dans le cas de transport. Seule E070 contient la date
* de crï¿½ation. AS4DATE et AS4TIME, qui sont normalement la date de
* derniï¿½re modification, ne peuvent pas changer puisqu'on est dans
* un systï¿½me cible des OT qui sont libï¿½rï¿½s donc non modifiables
* (alors que sur un systï¿½me de dï¿½v, c'est E070CREATE qui contient
* la date de crï¿½ation, et AS4DATE la date de crï¿½ation ou date de
* derniï¿½re modif)
    CALL FUNCTION 'RFC_READ_TABLE'
      DESTINATION p_target
      EXPORTING
        query_table          = l_table
      TABLES
        options              = lt_option
        fields               = lt_field
        data                 = lte_data
      EXCEPTIONS
        table_not_available  = 1
        table_without_data   = 2
        option_not_valid     = 3
        field_not_valid      = 4
        not_authorized       = 5
        data_buffer_exceeded = 6
        OTHERS               = 7.
    IF sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.

    SORT lte_data BY table_line ASCENDING.
    READ TABLE lte_data INDEX 1 INTO e_timestamp.

  ENDMETHOD.                    "get_creation_timestamp

*&---------------------------------------------------------------------*
*&      Form  GET_E071_DONT_EXIST_IN_TARGET
*&---------------------------------------------------------------------*
  METHOD get_e071_dont_exist_in_target.
*      USING
*        p_target TYPE rfcdest
*      CHANGING
*        ct_e071 TYPE ty_t_e071.

    DATA l_table TYPE dd02l-tabname.
    DATA lt_option TYPE TABLE OF rfc_db_opt.
    DATA lt_field TYPE TABLE OF rfc_db_fld.
    DATA lte_data TYPE TABLE OF tab512.
    DATA ls_option TYPE rfc_db_opt.
    DATA ls_field TYPE rfc_db_fld.
    TYPE-POOLS ctslg.
    DATA lt_e070 TYPE TABLE OF e070.
    DATA lt_e070_dont_exist_in_target TYPE TABLE OF e070.
    DATA ls_e070 TYPE e070.
    DATA lt_e071 TYPE TABLE OF e071.
    DATA lt_e071_bis TYPE TABLE OF e071.
    DATA ls_e071 TYPE e071.
    DATA ls_indx TYPE indx.


    REFRESH et_e071.

*------------
* rï¿½cupï¿½rer les OT de la derniï¿½re analyse, qui ï¿½ ce moment
* n'ï¿½taient pas encore dans le systï¿½me cible
*------------

* SRTFD is 22 characters
    CONCATENATE 'ZZCROSS_' p_target INTO ls_indx-srtfd.

    IMPORT
       content TO gs_cluster_content
       FROM DATABASE indx(zz) ID ls_indx-srtfd.
    IF sy-subrc <> 0.
* Premiï¿½re fois, on analyse absolument tout, les SELECT qui
* suivent risquent de prendre du temps!
      CLEAR gs_cluster_content.
    ENDIF.


*------------
*
*------------

* CURRENT SYSTEM
*   Lire les OT libï¿½rï¿½s depuis la derniï¿½re date d'analyse.
*   IMPORTANT : cette requï¿½te fonctionne uniquement parce que
*   les OT sont importï¿½s dans le mï¿½me systï¿½me (pour gï¿½rer les
*   donnï¿½es mandant-dï¿½pendantes telles les variantes) donc
*   l'import met ï¿½ jour AS4DATE et AS4TIME ï¿½ la date d'import
*   (qui est un petit peu supï¿½rieure ï¿½ la date d'export).
*   Sinon, pour connaï¿½tre la date/heure d'export, il faudrait
*   passer par le module fonction TR_READ_GLOBAL_INFO_OF_REQUEST
*   pour lire la log de l'OT.
    SELECT * FROM e070 INTO TABLE lt_e070
          WHERE strkorr = space
            AND trstatus IN ('R','N')
            AND ( as4date > gs_cluster_content-lastgentime(8)
            OR ( as4date = gs_cluster_content-lastgentime(8)
              AND as4time > gs_cluster_content-lastgentime+8 ) ).



* SYSTEME CIBLE
*   Recherche des OT crï¿½ï¿½s dans le systï¿½me cible depuis la derniï¿½re
*date d'analyse
    REFRESH lt_option.
    ls_option-text = 'STRKORR = '''''.
    APPEND ls_option TO lt_option.
    CONCATENATE 'AND ( AS4DATE > ''' gs_cluster_content-lastgentime(8)
'''' INTO ls_option-text.
    APPEND ls_option TO lt_option.
    CONCATENATE 'OR ( AS4DATE = ''' gs_cluster_content-lastgentime(8)
'''' INTO ls_option-text.
    APPEND ls_option TO lt_option.
    CONCATENATE 'AND AS4TIME > ''' gs_cluster_content-lastgentime+8
''' ) )' INTO ls_option-text.
    APPEND ls_option TO lt_option.

    REFRESH lt_field.
    ls_field-fieldname = 'TRKORR'.
    APPEND ls_field TO lt_field.

    REFRESH lte_data.
    l_table = 'E070'.
    CALL FUNCTION 'RFC_READ_TABLE'
      DESTINATION p_target
      EXPORTING
        query_table          = l_table
      TABLES
        options              = lt_option
        fields               = lt_field
        data                 = lte_data
      EXCEPTIONS
        table_not_available  = 1
        table_without_data   = 2
        option_not_valid     = 3
        field_not_valid      = 4
        not_authorized       = 5
        data_buffer_exceeded = 6
        OTHERS               = 7.
    IF sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.


    IF lt_e070[] IS NOT INITIAL OR lte_data[] IS NOT INITIAL.

* ANALYSER QUELS OT NE SE TROUVENT PAS ENCORE DANS LE SYSTEME CIBLE.
*   - Input: liste restreinte d'OT ï¿½ regarder = ceux libï¿½rï¿½s depuis
*     la derniï¿½re analyse + ceux qui ï¿½taient analysï¿½s et qui n'ï¿½taient
*     pas encore dans le systï¿½me cible ï¿½ la derniï¿½re analyse
      APPEND LINES OF gs_cluster_content-t_e070 TO lt_e070.

      SORT lt_e070 BY trkorr ASCENDING.
      SORT lte_data BY table_line ASCENDING.

      REFRESH lt_e070_dont_exist_in_target.
      LOOP AT lt_e070 INTO ls_e070.
        READ TABLE lte_data
              WITH KEY
                table_line = ls_e070-trkorr
              BINARY SEARCH
              TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          APPEND ls_e070 TO lt_e070_dont_exist_in_target.
        ENDIF.
      ENDLOOP.

* mettre dans le cluster ceux qui ne sont pas encore en cible
      gs_cluster_content-t_e070 = lt_e070_dont_exist_in_target.

* mettre ï¿½ jour le cluster
      CONCATENATE sy-datum sy-uzeit INTO gs_cluster_content-lastgentime.

      EXPORT
         content FROM gs_cluster_content
         TO DATABASE indx(zz) ID ls_indx-srtfd.

*------------
* Pour tous ces OT qui ne sont pas encore dans le systï¿½me cible,
* faire ces 3 ï¿½tapes
*------------
      IF lt_e070_dont_exist_in_target[] IS NOT INITIAL.

        SORT lt_e070_dont_exist_in_target BY trkorr.
        DELETE ADJACENT DUPLICATES FROM lt_e070_dont_exist_in_target
COMPARING trkorr.

* 1) dï¿½terminer tous les objets contenus dans ces OT
        SELECT * FROM e071 INTO TABLE lt_e071
              FOR ALL ENTRIES IN lt_e070_dont_exist_in_target
              WHERE trkorr = lt_e070_dont_exist_in_target-trkorr.
        IF lt_e071[] IS NOT INITIAL.

* 2) dï¿½terminer tous les OT contenant ces objets
*
*     cela se fait en NE GARDANT QUE les (objets des) OT qui existent
*dans les 2 systï¿½mes
          SORT lt_e071 BY pgmid object obj_name.
          DELETE ADJACENT DUPLICATES FROM lt_e071 COMPARING pgmid
object obj_name.
          SELECT * FROM e071 INTO TABLE lt_e071_bis
                FOR ALL ENTRIES IN lt_e071
                WHERE pgmid    = lt_e071-pgmid
                  AND object   = lt_e071-object
                  AND obj_name = lt_e071-obj_name.

          SORT lt_e071 BY trkorr.
          LOOP AT lt_e071_bis INTO ls_e071.
            READ TABLE lt_e071
                  WITH KEY
                    trkorr = ls_e071-trkorr
                  BINARY SEARCH
                  TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              DELETE lt_e071_bis.
            ENDIF.
          ENDLOOP.

* 3) les objets qui sont dans des OT, mais aucun n'est en cible, sont
*considï¿½rï¿½s
*    comme inexistants en cible
          SORT lt_e071 BY pgmid object obj_name.
          SORT lt_e071_bis BY pgmid object obj_name.
          LOOP AT lt_e071 INTO ls_e071.
            READ TABLE lt_e071_bis
                  WITH KEY
                    pgmid    = ls_e071-pgmid
                    object   = ls_e071-object
                    obj_name = ls_e071-obj_name
                  BINARY SEARCH
                  TRANSPORTING NO FIELDS.
            IF sy-subrc <> 0.
              APPEND ls_e071 TO et_e071.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ENDIF.

      SORT et_e071 BY pgmid object obj_name.

    ENDIF.

  ENDMETHOD.                    "get_e071_dont_exist_in_target

ENDCLASS.                    "lcl_tra_sim IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_aunit DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_aunit DEFINITION.
*   FOR
*  TESTING RISK LEVEL HARMLESS DURATION SHORT.
  PUBLIC SECTION.
    METHODS test1. " FOR TESTING.
ENDCLASS.                    "lcl_aunit DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_aunit IMPLEMENTATION.
  METHOD test1.
    DATA lo_tra_sim TYPE REF TO lcl_tra_sim.
    DATA lt_rng_trkorr TYPE lcl_tra_sim=>ty_ut_rng_trkorr.
    DATA ls_rng_trkorr TYPE LINE OF lcl_tra_sim=>ty_ut_rng_trkorr.
*ls_rng_trkorr-sign = 'I'.
*ls_rng_trkorr-option = 'EQ'.
*ls_rng_trkorr-low = 'DB1'.
*
*ls_rng_trkorr-pgmid = 'R3TR'.
*ls_rng_trkorr-object = 'TABL'.
*ls_rng_trkorr-obj_name = 'ZFAMLE'.
*APPEND ls_ TO lt_.
*lcl_tra_sim=>x( ).
*  CREATE OBJECT Lo_tra_sim
*    EXPORTING
*      p_target = 'DFDTI02F_IB1_33'
*      s_trkorr = lt_rng_trkorr
*      p_incstd = abap_false
*      p_srcsys = abap_false
*      p_timema = p_timem2.
*  Lo_tra_sim->main2( ).

    DATA ls_obj TYPE lcl_dev_cross_ref=>type_s_e071_objkey.
    DATA lo_exc TYPE REF TO cx_root.
    DATA gt_obj TYPE lcl_dev_cross_ref=>type_t_e071_rel.
    DATA gt_subobj TYPE lcl_dev_cross_ref=>type_t_e071_key.
    ls_obj-pgmid    = 'R3TR'.
    ls_obj-object   = 'FUGR'.
    ls_obj-obj_name = 'ZFAMTRGMODEDEF'.
    TRY.
        CALL METHOD lcl_dev_cross_ref=>get_reqobj
          EXPORTING
            is_e071_key = ls_obj
          IMPORTING
            et_e071_key = gt_obj.
        CALL METHOD lcl_dev_cross_ref=>get_subobj
          EXPORTING
            is_object    = ls_obj
          IMPORTING
            et_subobject = gt_subobj.

*    DATA lo_prog TYPE REF TO cl_abap_compiler.
*    DATA lt_types TYPE scr_rtags.
*    DATA ls_types TYPE LINE OF scr_rtags.
*    DATA lt_result2 TYPE scr_glrefs.
*    DATA ls_result2 TYPE scr_glref.
*    DATA lt_grades TYPE scr_grades.
*    DATA ls_grades TYPE LINE OF scr_grades.
**    DATA lt_missing_fields TYPE ty_it_type_of_missing.
**    FIELD-SYMBOLS <ls_e071_key> TYPE type_s_e071_rel.
*    DATA lo_symbol TYPE REF TO cl_abap_comp_symbol.
*    DATA lo_type TYPE REF TO cl_abap_comp_type.
*    DATA lo_data TYPE REF TO cl_abap_comp_data.
*    DATA lo_data_generic TYPE REF TO cl_abap_comp_data_generic.
*    DATA lo_data_table_w_header TYPE REF TO
*cl_abap_comp_table_with_head.
*    DATA lo_structure_type TYPE REF TO cl_abap_comp_structure_type.
*    DATA lo_class TYPE REF TO cl_abap_comp_class.
*
*    TYPES : BEGIN OF ty_ls_program,
*              object    TYPE e071-object,
*              obj_name  TYPE e071-obj_name,
*            END OF ty_ls_program.
*    DATA ls_program TYPE ty_ls_program.
*    FIELD-SYMBOLS <ls_program> TYPE ty_ls_program.
*    DATA lt_program TYPE TABLE OF ty_ls_program.
*      DATA l_program TYPE program.
**      DATA l_obj_name TYPE tadir-obj_name.
**      l_obj_name = <ls_program>-obj_name.
**      CALL FUNCTION 'RS_TADIR_TO_PROGNAME'
**        EXPORTING
**          object   = <ls_program>-object
**          obj_name = l_obj_name
**        IMPORTING
**          progname = l_program.
*l_program = 'ZCL_FTFILE_TE_FILE_UTILITIES==CP'.
*      CREATE OBJECT lo_prog
*        EXPORTING
*          p_name = l_program.
*
*      ls_types-sign = 'I'.
*      ls_types-option = 'EQ'.
*      ls_types-low = cl_abap_compiler=>tag_type.
*      APPEND ls_types TO lt_types.
*      ls_types-sign = 'I'.
*      ls_types-option = 'EQ'.
*      ls_types-low = cl_abap_compiler=>TAG_TYPE_OF.
*      APPEND ls_types TO lt_types.
*      ls_types-sign = 'I'.
*      ls_types-option = 'EQ'.
*      ls_types-low = cl_abap_compiler=>TAG_TYPE_POOL.
*      APPEND ls_types TO lt_types.
*      ls_grades-sign = 'I'.
*      ls_grades-option = 'EQ'.
*      ls_grades-low = cl_abap_compiler=>grade_direct.
*      APPEND ls_grades TO lt_grades.
*
*      lo_prog->get_all_refs(
*            EXPORTING
*              p_local = abap_true
*              p_types = lt_types
*              p_grades = lt_grades
*            IMPORTING
*              p_result = lt_result2 ).
*      LOOP AT lt_result2 INTO ls_result2
*            WHERE symbol IS BOUND.
*
*        lo_symbol = ls_result2-symbol.
*        CLEAR lo_type.
*        CASE ls_result2-tag.
*          WHEN cl_abap_compiler=>tag_type. "TY
*            lo_type ?= lo_symbol.
*            CASE lo_type->type_kind.
*              WHEN cl_abap_comp_type=>type_kind_structure.
*                lo_structure_type ?= lo_type.
*              WHEN cl_abap_comp_type=>type_kind_class.
*                lo_class ?= lo_type.
*              WHEN cl_abap_comp_type=>type_kind_interface.
*                ASSERT 1 = 1.
*              WHEN cl_abap_comp_type=>type_kind_table.
*                ASSERT 1 = 1.
*              WHEN cl_abap_comp_type=>type_kind_reference.
*                ASSERT 1 = 1.
*              WHEN cl_abap_comp_type=>type_kind_elementary.
*                ASSERT 1 = 1.
*            ENDCASE.
*          WHEN cl_abap_compiler=>tag_data. "DA
*            CLEAR lo_data.
*            CLEAR lo_data_table_w_header.
*            CLEAR lo_data_generic.
*            TRY.
*                lo_data ?= lo_symbol.
*              CATCH cx_sy_move_cast_error.
*                TRY.
*                    lo_data_table_w_header ?= lo_symbol.
*                  CATCH cx_sy_move_cast_error.
*                    lo_data_generic ?= lo_symbol.
*                ENDTRY.
*            ENDTRY.
*            IF lo_data IS BOUND.
*              IF lo_data->type IS NOT BOUND.
** cas se produisant avec les sous-classes, oï¿½ les DATA,
** CONSTANTS et autres, sont dï¿½finies dans les super-classes
** (sous-classe \TY:CL_GUI_SIMPLE_TREE\DA:EVENTID_SELECTION_CHANGED a
*TYPE not bound,
** mais sa super-classe
*\TY:CL_TREE_CONTROL_BASE\DA:EVENTID_SELECTION_CHANGED a TYPE bound)
*              ELSE.
*                lo_type = lo_data->type.
*              ENDIF.
*            ENDIF.
*        ENDCASE.
*        IF lo_type IS BOUND.
*        ENDIF.
*      ENDLOOP.
*    cl_aunit_assert=>assert_not_initial( act = g_data ).
      CATCH cx_root INTO lo_exc.
        lo_exc->get_longtext( ).
    ENDTRY.
  ENDMETHOD.                                                "test1
ENDCLASS.                    "lcl_aunit IMPLEMENTATION
